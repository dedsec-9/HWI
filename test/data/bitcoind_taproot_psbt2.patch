From ed386479463cf5ec398dbcdebf2eec41baf0ef69 Mon Sep 17 00:00:00 2001
From: Andrew Chow <achow101-github@achow101.com>
Date: Mon, 12 Jul 2021 15:31:12 -0400
Subject: [PATCH 01/48] Move individual KeyOriginInfo de/ser to separate
 function

To make it easier to de/serialize individual KeyOriginInfo for PSBTs,
separate the actual de/serialization of KeyOriginInfo to its own
function.

This is an additional separation where any length prefix is processed by
the caller.
---
 src/psbt.h | 31 +++++++++++++++++++++++--------
 1 file changed, 23 insertions(+), 8 deletions(-)

diff --git a/src/psbt.h b/src/psbt.h
index 8a9cbd33d2..e0512feb4f 100644
--- a/src/psbt.h
+++ b/src/psbt.h
@@ -98,22 +98,30 @@ void UnserializeFromVector(Stream& s, X&... args)
     }
 }
 
-// Deserialize an individual HD keypath to a stream
+// Deserialize bytes of given length from the stream as a KeyOriginInfo
 template<typename Stream>
-void DeserializeHDKeypath(Stream& s, KeyOriginInfo& hd_keypath)
+KeyOriginInfo DeserializeKeyOrigin(Stream& s, uint64_t length)
 {
     // Read in key path
-    uint64_t value_len = ReadCompactSize(s);
-    if (value_len % 4 || value_len == 0) {
+    if (length % 4 || length == 0) {
         throw std::ios_base::failure("Invalid length for HD key path");
     }
 
+    KeyOriginInfo hd_keypath;
     s >> hd_keypath.fingerprint;
-    for (unsigned int i = 4; i < value_len; i += sizeof(uint32_t)) {
+    for (unsigned int i = 4; i < length; i += sizeof(uint32_t)) {
         uint32_t index;
         s >> index;
         hd_keypath.path.push_back(index);
     }
+    return hd_keypath;
+}
+
+// Deserialize a length prefixed KeyOriginInfo from a stream
+template<typename Stream>
+void DeserializeHDKeypath(Stream& s, KeyOriginInfo& hd_keypath)
+{
+    hd_keypath = DeserializeKeyOrigin(s, ReadCompactSize(s));
 }
 
 // Deserialize HD keypaths into a map
@@ -140,17 +148,24 @@ void DeserializeHDKeypaths(Stream& s, const std::vector<unsigned char>& key, std
     hd_keypaths.emplace(pubkey, std::move(keypath));
 }
 
-// Serialize an individual HD keypath to a stream
+// Serialize a KeyOriginInfo to a stream
 template<typename Stream>
-void SerializeHDKeypath(Stream& s, KeyOriginInfo hd_keypath)
+void SerializeKeyOrigin(Stream& s, KeyOriginInfo hd_keypath)
 {
-    WriteCompactSize(s, (hd_keypath.path.size() + 1) * sizeof(uint32_t));
     s << hd_keypath.fingerprint;
     for (const auto& path : hd_keypath.path) {
         s << path;
     }
 }
 
+// Serialize a length prefixed KeyOriginInfo to a stream
+template<typename Stream>
+void SerializeHDKeypath(Stream& s, KeyOriginInfo hd_keypath)
+{
+    WriteCompactSize(s, (hd_keypath.path.size() + 1) * sizeof(uint32_t));
+    SerializeKeyOrigin(s, hd_keypath);
+}
+
 // Serialize HD keypaths to a stream from a map
 template<typename Stream>
 void SerializeHDKeypaths(Stream& s, const std::map<CPubKey, KeyOriginInfo>& hd_keypaths, CompactSizeWriter type)
-- 
2.36.1


From a41b109ad71ad924fb9c34deba1439d4a77c6624 Mon Sep 17 00:00:00 2001
From: Andrew Chow <achow101-github@achow101.com>
Date: Mon, 12 Jul 2021 17:04:46 -0400
Subject: [PATCH 02/48] Add TaprootBuilder::GetTreeTuples

GetTreeTuples returns the leaves in DFS order as tuples of depth, leaf
version, and script. This is a representation of the tree that can be
serialized.
---
 src/script/standard.cpp | 15 +++++++++++++++
 src/script/standard.h   |  2 ++
 2 files changed, 17 insertions(+)

diff --git a/src/script/standard.cpp b/src/script/standard.cpp
index e25155d3dd..010828d93d 100644
--- a/src/script/standard.cpp
+++ b/src/script/standard.cpp
@@ -642,3 +642,18 @@ std::optional<std::vector<std::tuple<int, CScript, int>>> InferTaprootTree(const
 
     return ret;
 }
+
+std::vector<std::tuple<uint8_t, uint8_t, CScript>> TaprootBuilder::GetTreeTuples() const
+{
+    assert(IsComplete());
+    std::vector<std::tuple<uint8_t, uint8_t, CScript>> tuples;
+    if (m_branch.size()) {
+        const auto& leaves = m_branch[0]->leaves;
+        for (const auto& leaf : leaves) {
+            uint8_t depth = (uint8_t)leaf.merkle_branch.size();
+            uint8_t leaf_ver = (uint8_t)leaf.leaf_version;
+            tuples.push_back(std::make_tuple(depth, leaf_ver, leaf.script));
+        }
+    }
+    return tuples;
+}
diff --git a/src/script/standard.h b/src/script/standard.h
index f0b143c52b..0e1cbc4690 100644
--- a/src/script/standard.h
+++ b/src/script/standard.h
@@ -321,6 +321,8 @@ public:
     static bool ValidDepths(const std::vector<int>& depths);
     /** Compute spending data (after Finalize()). */
     TaprootSpendData GetSpendData() const;
+    /** Returns a vector of tuples representing the depth, leaf version, and script */
+    std::vector<std::tuple<uint8_t, uint8_t, CScript>> GetTreeTuples() const;
 };
 
 /** Given a TaprootSpendData and the output key, reconstruct its script tree.
-- 
2.36.1


From a7728d5c735c18342d17209a6bebde041c8ed9d3 Mon Sep 17 00:00:00 2001
From: Andrew Chow <achow101-github@achow101.com>
Date: Mon, 12 Jul 2021 17:05:42 -0400
Subject: [PATCH 03/48] Add TaprootBuilder::IsEmpty

Helper function to know whether the tree has any data in it.
---
 src/script/standard.h | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/src/script/standard.h b/src/script/standard.h
index 0e1cbc4690..824709134f 100644
--- a/src/script/standard.h
+++ b/src/script/standard.h
@@ -313,6 +313,8 @@ public:
 
     /** Return true if so far all input was valid. */
     bool IsValid() const { return m_valid; }
+    /** Return true if there are no leaves */
+    bool IsEmpty() const { return m_branch.size() == 0; }
     /** Return whether there were either no leaves, or the leaves form a Huffman tree. */
     bool IsComplete() const { return m_valid && (m_branch.size() == 0 || (m_branch.size() == 1 && m_branch[0].has_value())); }
     /** Compute scriptPubKey (after Finalize()). */
-- 
2.36.1


From 180a70823e31f2c5b4f3c477d246793075da2c9b Mon Sep 17 00:00:00 2001
From: Andrew Chow <achow101-github@achow101.com>
Date: Mon, 12 Jul 2021 17:06:20 -0400
Subject: [PATCH 04/48] Add serialization methods to XOnlyPubKey

It is useful to have serialzation methods for XOnlyPubKey. These will
serialize the internal uint256, so it is not prefixed with the length as
CPubKey does.
---
 src/pubkey.h | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/src/pubkey.h b/src/pubkey.h
index dfe06f834c..463efe1b00 100644
--- a/src/pubkey.h
+++ b/src/pubkey.h
@@ -286,6 +286,9 @@ public:
     bool operator==(const XOnlyPubKey& other) const { return m_keydata == other.m_keydata; }
     bool operator!=(const XOnlyPubKey& other) const { return m_keydata != other.m_keydata; }
     bool operator<(const XOnlyPubKey& other) const { return m_keydata < other.m_keydata; }
+
+    //! Implement serialization without length prefixes since it is a fixed length
+    SERIALIZE_METHODS(XOnlyPubKey, obj) { READWRITE(obj.m_keydata); }
 };
 
 struct CExtPubKey {
-- 
2.36.1


From 5d3e0bae9b1c1cfd0bb7f87b79b54f4124db9f67 Mon Sep 17 00:00:00 2001
From: Andrew Chow <achow101-github@achow101.com>
Date: Mon, 12 Jul 2021 17:07:08 -0400
Subject: [PATCH 05/48] Implement de/ser of PSBT's Taproot fields

---
 src/psbt.h | 246 +++++++++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 246 insertions(+)

diff --git a/src/psbt.h b/src/psbt.h
index e0512feb4f..13e6a787ca 100644
--- a/src/psbt.h
+++ b/src/psbt.h
@@ -41,12 +41,21 @@ static constexpr uint8_t PSBT_IN_RIPEMD160 = 0x0A;
 static constexpr uint8_t PSBT_IN_SHA256 = 0x0B;
 static constexpr uint8_t PSBT_IN_HASH160 = 0x0C;
 static constexpr uint8_t PSBT_IN_HASH256 = 0x0D;
+static constexpr uint8_t PSBT_IN_TAP_KEY_SIG = 0x13;
+static constexpr uint8_t PSBT_IN_TAP_SCRIPT_SIG = 0x14;
+static constexpr uint8_t PSBT_IN_TAP_LEAF_SCRIPT = 0x15;
+static constexpr uint8_t PSBT_IN_TAP_BIP32_DERIVATION = 0x16;
+static constexpr uint8_t PSBT_IN_TAP_INTERNAL_KEY = 0x17;
+static constexpr uint8_t PSBT_IN_TAP_MERKLE_ROOT = 0x18;
 static constexpr uint8_t PSBT_IN_PROPRIETARY = 0xFC;
 
 // Output types
 static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;
 static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;
 static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;
+static constexpr uint8_t PSBT_OUT_TAP_INTERNAL_KEY = 0x05;
+static constexpr uint8_t PSBT_OUT_TAP_TREE = 0x06;
+static constexpr uint8_t PSBT_OUT_TAP_BIP32_DERIVATION = 0x07;
 static constexpr uint8_t PSBT_OUT_PROPRIETARY = 0xFC;
 
 // The separator is 0x00. Reading this in means that the unserializer can interpret it
@@ -194,6 +203,15 @@ struct PSBTInput
     std::map<uint256, std::vector<unsigned char>> sha256_preimages;
     std::map<uint160, std::vector<unsigned char>> hash160_preimages;
     std::map<uint256, std::vector<unsigned char>> hash256_preimages;
+
+    // Taproot fields
+    std::vector<unsigned char> m_tap_key_sig;
+    std::map<std::pair<XOnlyPubKey, uint256>, std::vector<unsigned char>> m_tap_script_sigs;
+    std::map<std::pair<CScript, int>, std::set<std::vector<unsigned char>, ShortestVectorFirstComparator>> m_tap_scripts;
+    std::map<XOnlyPubKey, std::pair<std::set<uint256>, KeyOriginInfo>> m_tap_bip32_paths;
+    XOnlyPubKey m_tap_internal_key;
+    uint256 m_tap_merkle_root;
+
     std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;
     std::set<PSBTProprietary> m_proprietary;
     std::optional<int> sighash_type;
@@ -268,6 +286,53 @@ struct PSBTInput
                 SerializeToVector(s, CompactSizeWriter(PSBT_IN_HASH256), Span{hash});
                 s << preimage;
             }
+
+            // Write taproot key sig
+            if (!m_tap_key_sig.empty()) {
+                SerializeToVector(s, PSBT_IN_TAP_KEY_SIG);
+                s << m_tap_key_sig;
+            }
+
+            // Write taproot script sigs
+            for (const auto& [pubkey_leaf, sig] : m_tap_script_sigs) {
+                const auto& [xonly, leaf_hash] = pubkey_leaf;
+                SerializeToVector(s, PSBT_IN_TAP_SCRIPT_SIG, xonly, leaf_hash);
+                s << sig;
+            }
+
+            // Write taproot leaf scripts
+            for (const auto& [leaf, control_blocks] : m_tap_scripts) {
+                const auto& [script, leaf_ver] = leaf;
+                for (const auto& control_block : control_blocks) {
+                    SerializeToVector(s, PSBT_IN_TAP_LEAF_SCRIPT, Span{control_block});
+                    std::vector<unsigned char> value_v(script.begin(), script.end());
+                    value_v.push_back((uint8_t)leaf_ver);
+                    s << value_v;
+                }
+            }
+
+            // Write taproot bip32 keypaths
+            for (const auto& [xonly, leaf_origin] : m_tap_bip32_paths) {
+                const auto& [leaf_hashes, origin] = leaf_origin;
+                SerializeToVector(s, PSBT_IN_TAP_BIP32_DERIVATION, xonly);
+                std::vector<unsigned char> value;
+                CVectorWriter s_value(s.GetType(), s.GetVersion(), value, 0);
+                s_value << leaf_hashes;
+                SerializeKeyOrigin(s_value, origin);
+                s << value;
+            }
+
+            // Write taproot internal key
+            if (!m_tap_internal_key.IsNull()) {
+                SerializeToVector(s, PSBT_IN_TAP_INTERNAL_KEY);
+                s << ToByteVector(m_tap_internal_key);
+            }
+
+            // Write taproot merkle root
+            if (!m_tap_merkle_root.IsNull()) {
+                SerializeToVector(s, PSBT_IN_TAP_MERKLE_ROOT);
+                SerializeToVector(s, m_tap_merkle_root);
+            }
         }
 
         // Write script sig
@@ -504,6 +569,101 @@ struct PSBTInput
                     hash256_preimages.emplace(hash, std::move(preimage));
                     break;
                 }
+                case PSBT_IN_TAP_KEY_SIG:
+                {
+                    if (!key_lookup.emplace(key).second) {
+                        throw std::ios_base::failure("Duplicate Key, input Taproot key signature already provided");
+                    } else if (key.size() != 1) {
+                        throw std::ios_base::failure("Input Taproot key signature key is more than one byte type");
+                    }
+                    s >> m_tap_key_sig;
+                    if (m_tap_key_sig.size() < 64) {
+                        throw std::ios_base::failure("Input Taproot key path signature is shorter than 64 bytes");
+                    } else if (m_tap_key_sig.size() > 65) {
+                        throw std::ios_base::failure("Input Taproot key path signature is longer than 65 bytes");
+                    }
+                    break;
+                }
+                case PSBT_IN_TAP_SCRIPT_SIG:
+                {
+                    if (!key_lookup.emplace(key).second) {
+                        throw std::ios_base::failure("Duplicate Key, input Taproot script signature already provided");
+                    } else if (key.size() != 65) {
+                        throw std::ios_base::failure("Input Taproot script signature key is not 65 bytes");
+                    }
+                    SpanReader s_key(s.GetType(), s.GetVersion(), Span{key}.subspan(1));
+                    XOnlyPubKey xonly;
+                    uint256 hash;
+                    s_key >> xonly;
+                    s_key >> hash;
+                    std::vector<unsigned char> sig;
+                    s >> sig;
+                    if (sig.size() < 64) {
+                        throw std::ios_base::failure("Input Taproot script path signature is shorter than 64 bytes");
+                    } else if (sig.size() > 65) {
+                        throw std::ios_base::failure("Input Taproot script path signature is longer than 65 bytes");
+                    }
+                    m_tap_script_sigs.emplace(std::make_pair(xonly, hash), sig);
+                    break;
+                }
+                case PSBT_IN_TAP_LEAF_SCRIPT:
+                {
+                    if (!key_lookup.emplace(key).second) {
+                        throw std::ios_base::failure("Duplicate Key, input Taproot leaf script already provided");
+                    } else if (key.size() < 34) {
+                        throw std::ios_base::failure("Taproot leaf script key is not at least 34 bytes");
+                    } else if ((key.size() - 2) % 32 != 0) {
+                        throw std::ios_base::failure("Input Taproot leaf script key's control block size is not valid");
+                    }
+                    std::vector<unsigned char> script_v;
+                    s >> script_v;
+                    assert(!script_v.empty());
+                    uint8_t leaf_ver = script_v.back();
+                    script_v.pop_back();
+                    const auto leaf_script = std::make_pair(CScript(script_v.begin(), script_v.end()), (int)leaf_ver);
+                    m_tap_scripts[leaf_script].insert(std::vector<unsigned char>(key.begin() + 1, key.end()));
+                    break;
+                }
+                case PSBT_IN_TAP_BIP32_DERIVATION:
+                {
+                    if (!key_lookup.emplace(key).second) {
+                        throw std::ios_base::failure("Duplicate Key, input Taproot BIP32 keypath already provided");
+                    } else if (key.size() != 33) {
+                        throw std::ios_base::failure("Input Taproot BIP32 keypath key is not at 33 bytes");
+                    }
+                    SpanReader s_key(s.GetType(), s.GetVersion(), Span{key}.subspan(1));
+                    XOnlyPubKey xonly;
+                    s_key >> xonly;
+                    std::set<uint256> leaf_hashes;
+                    uint64_t value_len = ReadCompactSize(s);
+                    size_t before_hashes = s.size();
+                    s >> leaf_hashes;
+                    size_t after_hashes = s.size();
+                    size_t hashes_len = before_hashes - after_hashes;
+                    size_t origin_len = value_len - hashes_len;
+                    m_tap_bip32_paths.emplace(xonly, std::make_pair(leaf_hashes, DeserializeKeyOrigin(s, origin_len)));
+                    break;
+                }
+                case PSBT_IN_TAP_INTERNAL_KEY:
+                {
+                    if (!key_lookup.emplace(key).second) {
+                        throw std::ios_base::failure("Duplicate Key, input Taproot internal key already provided");
+                    } else if (key.size() != 1) {
+                        throw std::ios_base::failure("Input Taproot internal key key is more than one byte type");
+                    }
+                    UnserializeFromVector(s, m_tap_internal_key);
+                    break;
+                }
+                case PSBT_IN_TAP_MERKLE_ROOT:
+                {
+                    if (!key_lookup.emplace(key).second) {
+                        throw std::ios_base::failure("Duplicate Key, input Taproot merkle root already provided");
+                    } else if (key.size() != 1) {
+                        throw std::ios_base::failure("Input Taproot merkle root key is more than one byte type");
+                    }
+                    UnserializeFromVector(s, m_tap_merkle_root);
+                    break;
+                }
                 case PSBT_IN_PROPRIETARY:
                 {
                     PSBTProprietary this_prop;
@@ -548,6 +708,9 @@ struct PSBTOutput
     CScript redeem_script;
     CScript witness_script;
     std::map<CPubKey, KeyOriginInfo> hd_keypaths;
+    XOnlyPubKey m_tap_internal_key;
+    TaprootBuilder m_tap_tree;
+    std::map<XOnlyPubKey, std::pair<std::set<uint256>, KeyOriginInfo>> m_tap_bip32_paths;
     std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;
     std::set<PSBTProprietary> m_proprietary;
 
@@ -580,6 +743,40 @@ struct PSBTOutput
             s << entry.value;
         }
 
+        // Write taproot internal key
+        if (!m_tap_internal_key.IsNull()) {
+            SerializeToVector(s, PSBT_OUT_TAP_INTERNAL_KEY);
+            s << ToByteVector(m_tap_internal_key);
+        }
+
+        // Write taproot tree
+        if (!m_tap_tree.IsEmpty()) {
+            SerializeToVector(s, PSBT_OUT_TAP_TREE);
+            std::vector<unsigned char> value;
+            CVectorWriter s_value(s.GetType(), s.GetVersion(), value, 0);
+            const auto& tuples = m_tap_tree.GetTreeTuples();
+            for (const auto& tuple : tuples) {
+                uint8_t depth = std::get<0>(tuple);
+                uint8_t leaf_ver = std::get<1>(tuple);
+                CScript script = std::get<2>(tuple);
+                s_value << depth;
+                s_value << leaf_ver;
+                s_value << script;
+            }
+            s << value;
+        }
+
+        // Write taproot bip32 keypaths
+        for (const auto& [xonly, leaf] : m_tap_bip32_paths) {
+            const auto& [leaf_hashes, origin] = leaf;
+            SerializeToVector(s, PSBT_OUT_TAP_BIP32_DERIVATION, xonly);
+            std::vector<unsigned char> value;
+            CVectorWriter s_value(s.GetType(), s.GetVersion(), value, 0);
+            s_value << leaf_hashes;
+            SerializeKeyOrigin(s_value, origin);
+            s << value;
+        }
+
         // Write unknown things
         for (auto& entry : unknown) {
             s << entry.first;
@@ -640,6 +837,55 @@ struct PSBTOutput
                     DeserializeHDKeypaths(s, key, hd_keypaths);
                     break;
                 }
+                case PSBT_OUT_TAP_INTERNAL_KEY:
+                {
+                    if (!key_lookup.emplace(key).second) {
+                        throw std::ios_base::failure("Duplicate Key, output Taproot internal key already provided");
+                    } else if (key.size() != 1) {
+                        throw std::ios_base::failure("Output Taproot internal key key is more than one byte type");
+                    }
+                    UnserializeFromVector(s, m_tap_internal_key);
+                    break;
+                }
+                case PSBT_OUT_TAP_TREE:
+                {
+                    if (!key_lookup.emplace(key).second) {
+                        throw std::ios_base::failure("Duplicate Key, output Taproot tree already provided");
+                    } else if (key.size() != 1) {
+                        throw std::ios_base::failure("Output Taproot tree key is more than one byte type");
+                    }
+                    std::vector<unsigned char> tree_v;
+                    s >> tree_v;
+                    SpanReader s_tree(s.GetType(), s.GetVersion(), tree_v);
+                    while (!s_tree.empty()) {
+                        uint8_t depth;
+                        uint8_t leaf_ver;
+                        CScript script;
+                        s_tree >> depth;
+                        s_tree >> leaf_ver;
+                        s_tree >> script;
+                        m_tap_tree.Add((int)depth, script, (int)leaf_ver, true /* track */);
+                    }
+                    break;
+                }
+                case PSBT_OUT_TAP_BIP32_DERIVATION:
+                {
+                    if (!key_lookup.emplace(key).second) {
+                        throw std::ios_base::failure("Duplicate Key, output Taproot BIP32 keypath already provided");
+                    } else if (key.size() != 33) {
+                        throw std::ios_base::failure("Output Taproot BIP32 keypath key is not at 33 bytes");
+                    }
+                    XOnlyPubKey xonly(uint256({key.begin() + 1, key.begin() + 33}));
+                    std::set<uint256> leaf_hashes;
+                    uint64_t value_len = ReadCompactSize(s);
+                    size_t before_hashes = s.size();
+                    s >> leaf_hashes;
+                    size_t after_hashes = s.size();
+                    size_t hashes_len = before_hashes - after_hashes;
+                    size_t origin_len = value_len - hashes_len;
+                    m_tap_bip32_paths.emplace(xonly, std::make_pair(leaf_hashes, DeserializeKeyOrigin(s, origin_len)));
+                    break;
+                }
                 case PSBT_OUT_PROPRIETARY:
                 {
                     PSBTProprietary this_prop;
-- 
2.36.1


From 8b72bff08f781ebcec9607b95b2580e045d6cc8b Mon Sep 17 00:00:00 2001
From: Andrew Chow <achow101-github@achow101.com>
Date: Mon, 19 Jul 2021 15:29:29 -0400
Subject: [PATCH 06/48] Fill PSBT Taproot input data to/from SignatureData

---
 src/psbt.cpp      | 36 ++++++++++++++++++++++++++++++++++++
 src/script/sign.h |  1 +
 2 files changed, 37 insertions(+)

diff --git a/src/psbt.cpp b/src/psbt.cpp
index c1c8a385cc..ba32d7acae 100644
--- a/src/psbt.cpp
+++ b/src/psbt.cpp
@@ -113,6 +113,24 @@ void PSBTInput::FillSignatureData(SignatureData& sigdata) const
     for (const auto& key_pair : hd_keypaths) {
         sigdata.misc_pubkeys.emplace(key_pair.first.GetID(), key_pair);
     }
+    if (!m_tap_key_sig.empty()) {
+        sigdata.taproot_key_path_sig = m_tap_key_sig;
+    }
+    for (const auto& [pubkey_leaf, sig] : m_tap_script_sigs) {
+        sigdata.taproot_script_sigs.emplace(pubkey_leaf, sig);
+    }
+    if (!m_tap_internal_key.IsNull()) {
+        sigdata.tr_spenddata.internal_key = m_tap_internal_key;
+    }
+    if (!m_tap_merkle_root.IsNull()) {
+        sigdata.tr_spenddata.merkle_root = m_tap_merkle_root;
+    }
+    for (const auto& [leaf_script, control_block] : m_tap_scripts) {
+        sigdata.tr_spenddata.scripts.emplace(leaf_script, control_block);
+    }
+    for (const auto& [pubkey, leaf_origin] : m_tap_bip32_paths) {
+        sigdata.taproot_misc_pubkeys.emplace(pubkey, leaf_origin);
+    }
 }
 
 void PSBTInput::FromSignatureData(const SignatureData& sigdata)
@@ -142,6 +160,24 @@ void PSBTInput::FromSignatureData(const SignatureData& sigdata)
     for (const auto& entry : sigdata.misc_pubkeys) {
         hd_keypaths.emplace(entry.second);
     }
+    if (!sigdata.taproot_key_path_sig.empty()) {
+        m_tap_key_sig = sigdata.taproot_key_path_sig;
+    }
+    for (const auto& [pubkey_leaf, sig] : sigdata.taproot_script_sigs) {
+        m_tap_script_sigs.emplace(pubkey_leaf, sig);
+    }
+    if (!sigdata.tr_spenddata.internal_key.IsNull()) {
+        m_tap_internal_key = sigdata.tr_spenddata.internal_key;
+    }
+    if (!sigdata.tr_spenddata.merkle_root.IsNull()) {
+        m_tap_merkle_root = sigdata.tr_spenddata.merkle_root;
+    }
+    for (const auto& [leaf_script, control_block] : sigdata.tr_spenddata.scripts) {
+        m_tap_scripts.emplace(leaf_script, control_block);
+    }
+    for (const auto& [pubkey, leaf_origin] : sigdata.taproot_misc_pubkeys) {
+        m_tap_bip32_paths.emplace(pubkey, leaf_origin);
+    }
 }
 
 void PSBTInput::Merge(const PSBTInput& input)
diff --git a/src/script/sign.h b/src/script/sign.h
index 71203d08ec..cb3c229298 100644
--- a/src/script/sign.h
+++ b/src/script/sign.h
@@ -74,6 +74,7 @@ struct SignatureData {
     std::map<CKeyID, std::pair<CPubKey, KeyOriginInfo>> misc_pubkeys;
     std::vector<unsigned char> taproot_key_path_sig; /// Schnorr signature for key path spending
     std::map<std::pair<XOnlyPubKey, uint256>, std::vector<unsigned char>> taproot_script_sigs; ///< (Partial) schnorr signatures, indexed by XOnlyPubKey and leaf_hash.
+    std::map<XOnlyPubKey, std::pair<std::set<uint256>, KeyOriginInfo>> taproot_misc_pubkeys; ///< Miscellaneous Taproot pubkeys involved in this input along with their leaf script hashes and key origin data. Also includes the Taproot internal key (may have no leaf script hashes).
     std::vector<CKeyID> missing_pubkeys; ///< KeyIDs of pubkeys which could not be found
     std::vector<CKeyID> missing_sigs; ///< KeyIDs of pubkeys for signatures which could not be found
     uint160 missing_redeem_script; ///< ScriptID of the missing redeemScript (if any)
-- 
2.36.1


From bb88ff7afe95c16e388d8da0d5f4483e9e9614c9 Mon Sep 17 00:00:00 2001
From: Andrew Chow <achow101-github@achow101.com>
Date: Mon, 19 Jul 2021 15:29:55 -0400
Subject: [PATCH 07/48] Fetch key origins for Taproot keys

---
 src/script/sign.cpp | 19 +++++++++++++++++++
 1 file changed, 19 insertions(+)

diff --git a/src/script/sign.cpp b/src/script/sign.cpp
index 2d569d674a..e46d9be7d4 100644
--- a/src/script/sign.cpp
+++ b/src/script/sign.cpp
@@ -169,6 +169,17 @@ static bool SignTaprootScript(const SigningProvider& provider, const BaseSignatu
     // <xonly pubkey> OP_CHECKSIG
     if (script.size() == 34 && script[33] == OP_CHECKSIG && script[0] == 0x20) {
         XOnlyPubKey pubkey{Span{script}.subspan(1, 32)};
+
+        KeyOriginInfo info;
+        if (provider.GetKeyOriginByXOnly(pubkey, info)) {
+            auto it = sigdata.taproot_misc_pubkeys.find(pubkey);
+            if (it == sigdata.taproot_misc_pubkeys.end()) {
+                sigdata.taproot_misc_pubkeys.emplace(pubkey, std::make_pair(std::set<uint256>({leaf_hash}), info));
+            } else {
+                it->second.first.insert(leaf_hash);
+            }
+        }
+
         std::vector<unsigned char> sig;
         if (CreateTaprootScriptSig(creator, sigdata, provider, sig, pubkey, leaf_hash, sigversion)) {
             result = Vector(std::move(sig));
@@ -213,6 +224,14 @@ static bool SignTaproot(const SigningProvider& provider, const BaseSignatureCrea
 
     // Try key path spending.
     {
+        KeyOriginInfo info;
+        if (provider.GetKeyOriginByXOnly(spenddata.internal_key, info)) {
+            auto it = sigdata.taproot_misc_pubkeys.find(spenddata.internal_key);
+            if (it == sigdata.taproot_misc_pubkeys.end()) {
+                sigdata.taproot_misc_pubkeys.emplace(spenddata.internal_key, std::make_pair(std::set<uint256>(), info));
+            }
+        }
+
         std::vector<unsigned char> sig;
         if (sigdata.taproot_key_path_sig.size() == 0) {
             if (creator.CreateSchnorrSig(provider, sig, spenddata.internal_key, nullptr, &spenddata.merkle_root, SigVersion::TAPROOT)) {
-- 
2.36.1


From b3087589961f971308106384f378973e6b0a3e69 Mon Sep 17 00:00:00 2001
From: Andrew Chow <achow101-github@achow101.com>
Date: Mon, 19 Jul 2021 16:01:12 -0400
Subject: [PATCH 08/48] Store TaprootBuilder in SigningProviders instead of
 TaprootSpendData

TaprootSpendData can be gotten from TaprootBuilder, however for PSBT, we
also need TaprootBuilders directly (for the outputs). So we store the
TaprootBuilder in the FlatSigningProvider and when the TaprootSpendData
is needed, we generate it on the fly using the stored builder.
---
 src/script/descriptor.cpp      |  2 +-
 src/script/signingprovider.cpp | 21 ++++++++++++++++-----
 src/script/signingprovider.h   |  5 ++++-
 3 files changed, 21 insertions(+), 7 deletions(-)

diff --git a/src/script/descriptor.cpp b/src/script/descriptor.cpp
index cece0b60ce..ca0170c84b 100644
--- a/src/script/descriptor.cpp
+++ b/src/script/descriptor.cpp
@@ -882,7 +882,7 @@ protected:
         if (!xpk.IsFullyValid()) return {};
         builder.Finalize(xpk);
         WitnessV1Taproot output = builder.GetOutput();
-        out.tr_spenddata[output].Merge(builder.GetSpendData());
+        out.tr_trees[output] = builder;
         out.pubkeys.emplace(keys[0].GetID(), keys[0]);
         return Vector(GetScriptForDestination(output));
     }
diff --git a/src/script/signingprovider.cpp b/src/script/signingprovider.cpp
index 552934e0eb..c624a17628 100644
--- a/src/script/signingprovider.cpp
+++ b/src/script/signingprovider.cpp
@@ -48,6 +48,10 @@ bool HidingSigningProvider::GetTaprootSpendData(const XOnlyPubKey& output_key, T
 {
     return m_provider->GetTaprootSpendData(output_key, spenddata);
 }
+bool HidingSigningProvider::GetTaprootBuilder(const XOnlyPubKey& output_key, TaprootBuilder& builder) const
+{
+    return m_provider->GetTaprootBuilder(output_key, builder);
+}
 
 bool FlatSigningProvider::GetCScript(const CScriptID& scriptid, CScript& script) const { return LookupHelper(scripts, scriptid, script); }
 bool FlatSigningProvider::GetPubKey(const CKeyID& keyid, CPubKey& pubkey) const { return LookupHelper(pubkeys, keyid, pubkey); }
@@ -61,7 +65,16 @@ bool FlatSigningProvider::GetKeyOrigin(const CKeyID& keyid, KeyOriginInfo& info)
 bool FlatSigningProvider::GetKey(const CKeyID& keyid, CKey& key) const { return LookupHelper(keys, keyid, key); }
 bool FlatSigningProvider::GetTaprootSpendData(const XOnlyPubKey& output_key, TaprootSpendData& spenddata) const
 {
-    return LookupHelper(tr_spenddata, output_key, spenddata);
+    TaprootBuilder builder;
+    if (LookupHelper(tr_trees, output_key, builder)) {
+        spenddata = builder.GetSpendData();
+        return true;
+    }
+    return false;
+}
+bool FlatSigningProvider::GetTaprootBuilder(const XOnlyPubKey& output_key, TaprootBuilder& builder) const
+{
+    return LookupHelper(tr_trees, output_key, builder);
 }
 
 FlatSigningProvider Merge(const FlatSigningProvider& a, const FlatSigningProvider& b)
@@ -75,10 +88,8 @@ FlatSigningProvider Merge(const FlatSigningProvider& a, const FlatSigningProvide
     ret.keys.insert(b.keys.begin(), b.keys.end());
     ret.origins = a.origins;
     ret.origins.insert(b.origins.begin(), b.origins.end());
-    ret.tr_spenddata = a.tr_spenddata;
-    for (const auto& [output_key, spenddata] : b.tr_spenddata) {
-        ret.tr_spenddata[output_key].Merge(spenddata);
-    }
+    ret.tr_trees = a.tr_trees;
+    ret.tr_trees.insert(b.tr_trees.begin(), b.tr_trees.end());
     return ret;
 }
 
diff --git a/src/script/signingprovider.h b/src/script/signingprovider.h
index f1bded1a8c..792cc903f2 100644
--- a/src/script/signingprovider.h
+++ b/src/script/signingprovider.h
@@ -25,6 +25,7 @@ public:
     virtual bool HaveKey(const CKeyID &address) const { return false; }
     virtual bool GetKeyOrigin(const CKeyID& keyid, KeyOriginInfo& info) const { return false; }
     virtual bool GetTaprootSpendData(const XOnlyPubKey& output_key, TaprootSpendData& spenddata) const { return false; }
+    virtual bool GetTaprootBuilder(const XOnlyPubKey& output_key, TaprootBuilder& builder) const { return false; }
 
     bool GetKeyByXOnly(const XOnlyPubKey& pubkey, CKey& key) const
     {
@@ -67,6 +68,7 @@ public:
     bool GetKey(const CKeyID& keyid, CKey& key) const override;
     bool GetKeyOrigin(const CKeyID& keyid, KeyOriginInfo& info) const override;
     bool GetTaprootSpendData(const XOnlyPubKey& output_key, TaprootSpendData& spenddata) const override;
+    bool GetTaprootBuilder(const XOnlyPubKey& output_key, TaprootBuilder& builder) const override;
 };
 
 struct FlatSigningProvider final : public SigningProvider
@@ -75,13 +77,14 @@ struct FlatSigningProvider final : public SigningProvider
     std::map<CKeyID, CPubKey> pubkeys;
     std::map<CKeyID, std::pair<CPubKey, KeyOriginInfo>> origins;
     std::map<CKeyID, CKey> keys;
-    std::map<XOnlyPubKey, TaprootSpendData> tr_spenddata; /** Map from output key to spend data. */
+    std::map<XOnlyPubKey, TaprootBuilder> tr_trees; /** Map from output key to Taproot tree (which can then make the TaprootSpendData */
 
     bool GetCScript(const CScriptID& scriptid, CScript& script) const override;
     bool GetPubKey(const CKeyID& keyid, CPubKey& pubkey) const override;
     bool GetKeyOrigin(const CKeyID& keyid, KeyOriginInfo& info) const override;
     bool GetKey(const CKeyID& keyid, CKey& key) const override;
     bool GetTaprootSpendData(const XOnlyPubKey& output_key, TaprootSpendData& spenddata) const override;
+    bool GetTaprootBuilder(const XOnlyPubKey& output_key, TaprootBuilder& builder) const override;
 };
 
 FlatSigningProvider Merge(const FlatSigningProvider& a, const FlatSigningProvider& b);
-- 
2.36.1


From b96772eb1ab9396de913177a753ac45b3e8f2082 Mon Sep 17 00:00:00 2001
From: Andrew Chow <achow101-github@achow101.com>
Date: Mon, 19 Jul 2021 16:02:36 -0400
Subject: [PATCH 09/48] Fill PSBT Taproot output data to/from SignatureData

---
 src/psbt.cpp        | 19 +++++++++++++++++++
 src/script/sign.cpp |  4 ++++
 src/script/sign.h   |  1 +
 3 files changed, 24 insertions(+)

diff --git a/src/psbt.cpp b/src/psbt.cpp
index ba32d7acae..2b2070e66e 100644
--- a/src/psbt.cpp
+++ b/src/psbt.cpp
@@ -213,6 +213,16 @@ void PSBTOutput::FillSignatureData(SignatureData& sigdata) const
     for (const auto& key_pair : hd_keypaths) {
         sigdata.misc_pubkeys.emplace(key_pair.first.GetID(), key_pair);
     }
+    if (!m_tap_internal_key.IsNull()) {
+        sigdata.tr_spenddata.internal_key = m_tap_internal_key;
+    }
+    if (!m_tap_tree.IsEmpty()) {
+        TaprootSpendData spenddata = m_tap_tree.GetSpendData();
+        sigdata.tr_spenddata.Merge(spenddata);
+    }
+    for (const auto& [pubkey, leaf_origin] : m_tap_bip32_paths) {
+        sigdata.taproot_misc_pubkeys.emplace(pubkey, leaf_origin);
+    }
 }
 
 void PSBTOutput::FromSignatureData(const SignatureData& sigdata)
@@ -226,6 +236,15 @@ void PSBTOutput::FromSignatureData(const SignatureData& sigdata)
     for (const auto& entry : sigdata.misc_pubkeys) {
         hd_keypaths.emplace(entry.second);
     }
+    if (!sigdata.tr_spenddata.internal_key.IsNull()) {
+        m_tap_internal_key = sigdata.tr_spenddata.internal_key;
+    }
+    if (!sigdata.tr_builder.IsEmpty()) {
+        m_tap_tree = sigdata.tr_builder;
+    }
+    for (const auto& [pubkey, leaf_origin] : sigdata.taproot_misc_pubkeys) {
+        m_tap_bip32_paths.emplace(pubkey, leaf_origin);
+    }
 }
 
 bool PSBTOutput::IsNull() const
diff --git a/src/script/sign.cpp b/src/script/sign.cpp
index e46d9be7d4..5cd773f6ee 100644
--- a/src/script/sign.cpp
+++ b/src/script/sign.cpp
@@ -216,11 +216,15 @@ static bool SignTaprootScript(const SigningProvider& provider, const BaseSignatu
 static bool SignTaproot(const SigningProvider& provider, const BaseSignatureCreator& creator, const WitnessV1Taproot& output, SignatureData& sigdata, std::vector<valtype>& result)
 {
     TaprootSpendData spenddata;
+    TaprootBuilder builder;
 
     // Gather information about this output.
     if (provider.GetTaprootSpendData(output, spenddata)) {
         sigdata.tr_spenddata.Merge(spenddata);
     }
+    if (provider.GetTaprootBuilder(output, builder)) {
+        sigdata.tr_builder = builder;
+    }
 
     // Try key path spending.
     {
diff --git a/src/script/sign.h b/src/script/sign.h
index cb3c229298..fed0450114 100644
--- a/src/script/sign.h
+++ b/src/script/sign.h
@@ -70,6 +70,7 @@ struct SignatureData {
     CScript witness_script; ///< The witnessScript (if any) for the input. witnessScripts are used in P2WSH outputs.
     CScriptWitness scriptWitness; ///< The scriptWitness of an input. Contains complete signatures or the traditional partial signatures format. scriptWitness is part of a transaction input per BIP 144.
     TaprootSpendData tr_spenddata; ///< Taproot spending data.
+    TaprootBuilder tr_builder; ///< Taproot tree used to build tr_spenddata.
     std::map<CKeyID, SigPair> signatures; ///< BIP 174 style partial signatures for the input. May contain all signatures necessary for producing a final scriptSig or scriptWitness.
     std::map<CKeyID, std::pair<CPubKey, KeyOriginInfo>> misc_pubkeys;
     std::vector<unsigned char> taproot_key_path_sig; /// Schnorr signature for key path spending
-- 
2.36.1


From d4b12ba7ba2844a83ab6c210f12f195da1938d49 Mon Sep 17 00:00:00 2001
From: Andrew Chow <achow101-github@achow101.com>
Date: Mon, 19 Jul 2021 16:54:16 -0400
Subject: [PATCH 10/48] Implement decodepsbt for Taproot fields

---
 src/rpc/rawtransaction.cpp | 169 ++++++++++++++++++++++++++++++++++++-
 1 file changed, 168 insertions(+), 1 deletion(-)

diff --git a/src/rpc/rawtransaction.cpp b/src/rpc/rawtransaction.cpp
index b9b8c36bb3..5a5743325b 100644
--- a/src/rpc/rawtransaction.cpp
+++ b/src/rpc/rawtransaction.cpp
@@ -790,6 +790,43 @@ static RPCHelpMan decodepsbt()
                                 {
                                     {RPCResult::Type::STR, "hash", "The hash and preimage that corresponds to it."},
                                 }},
+                                {RPCResult::Type::STR_HEX, "taproot_key_path_sig", /*optional=*/ true, "hex-encoded signature for the Taproot key path spend"},
+                                {RPCResult::Type::ARR, "taproot_script_path_sigs", /*optional=*/ true, "",
+                                {
+                                    {RPCResult::Type::OBJ, "signature", /*optional=*/ true, "The signature for the pubkey and leaf hash combination",
+                                    {
+                                        {RPCResult::Type::STR, "pubkey", "The x-only pubkey for this signature"},
+                                        {RPCResult::Type::STR, "leaf_hash", "The leaf hash for this signature"},
+                                        {RPCResult::Type::STR, "sig", "The signature itself"},
+                                    }},
+                                }},
+                                {RPCResult::Type::ARR, "taproot_scripts", /*optional=*/ true, "",
+                                {
+                                    {RPCResult::Type::OBJ, "", "",
+                                    {
+                                        {RPCResult::Type::STR_HEX, "script", "A leaf script"},
+                                        {RPCResult::Type::NUM, "leaf_ver", "The version number for the leaf script"},
+                                        {RPCResult::Type::ARR, "control_blocks", "The control blocks for this script",
+                                        {
+                                            {RPCResult::Type::STR_HEX, "control_block", "A hex-encoded control block for this script"},
+                                        }},
+                                    }},
+                                }},
+                                {RPCResult::Type::ARR, "taproot_bip32_derivs", /*optional=*/ true, "",
+                                {
+                                    {RPCResult::Type::OBJ, "", "",
+                                    {
+                                        {RPCResult::Type::STR, "pubkey", "The x-only public key this path corresponds to"},
+                                        {RPCResult::Type::STR, "master_fingerprint", "The fingerprint of the master key"},
+                                        {RPCResult::Type::STR, "path", "The path"},
+                                        {RPCResult::Type::ARR, "leaf_hashes", "The hashes of the leaves this pubkey appears in",
+                                        {
+                                            {RPCResult::Type::STR_HEX, "hash", "The hash of a leaf this pubkey appears in"},
+                                        }},
+                                    }},
+                                }},
+                                {RPCResult::Type::STR_HEX, "taproot_internal_key", /*optional=*/ true, "The hex-encoded Taproot x-only internal key"},
+                                {RPCResult::Type::STR_HEX, "taproot_merkle_root", /*optional=*/ true, "The hex-encoded Taproot merkle root"},
                                 {RPCResult::Type::OBJ_DYN, "unknown", /*optional=*/ true, "The unknown input fields",
                                 {
                                     {RPCResult::Type::STR_HEX, "key", "(key-value pair) An unknown key-value pair"},
@@ -831,7 +868,30 @@ static RPCHelpMan decodepsbt()
                                         {RPCResult::Type::STR, "path", "The path"},
                                     }},
                                 }},
-                                {RPCResult::Type::OBJ_DYN, "unknown", /*optional=*/true, "The unknown global fields",
+                                {RPCResult::Type::STR_HEX, "taproot_internal_key", /*optional=*/ true, "The hex-encoded Taproot x-only internal key"},
+                                {RPCResult::Type::ARR, "taproot_tree", /*optional=*/ true, "The tuples that make up the Taproot tree, in depth first search order",
+                                {
+                                    {RPCResult::Type::OBJ, "tuple", /*optional=*/ true, "A single leaf script in the taproot tree",
+                                    {
+                                        {RPCResult::Type::NUM, "depth", "The depth of this element in the tree"},
+                                        {RPCResult::Type::NUM, "leaf_ver", "The version of this leaf"},
+                                        {RPCResult::Type::STR, "script", "The hex-encoded script itself"},
+                                    }},
+                                }},
+                                {RPCResult::Type::ARR, "taproot_bip32_derivs", /*optional=*/ true, "",
+                                {
+                                    {RPCResult::Type::OBJ, "", "",
+                                    {
+                                        {RPCResult::Type::STR, "pubkey", "The x-only public key this path corresponds to"},
+                                        {RPCResult::Type::STR, "master_fingerprint", "The fingerprint of the master key"},
+                                        {RPCResult::Type::STR, "path", "The path"},
+                                        {RPCResult::Type::ARR, "leaf_hashes", "The hashes of the leaves this pubkey appears in",
+                                        {
+                                            {RPCResult::Type::STR_HEX, "hash", "The hash of a leaf this pubkey appears in"},
+                                        }},
+                                    }},
+                                }},
+                                {RPCResult::Type::OBJ_DYN, "unknown", /*optional=*/true, "The unknown output fields",
                                 {
                                     {RPCResult::Type::STR_HEX, "key", "(key-value pair) An unknown key-value pair"},
                                 }},
@@ -1045,6 +1105,72 @@ static RPCHelpMan decodepsbt()
             in.pushKV("hash256_preimages", hash256_preimages);
         }
 
+        // Taproot key path signature
+        if (!input.m_tap_key_sig.empty()) {
+            in.pushKV("taproot_key_path_sig", HexStr(input.m_tap_key_sig));
+        }
+
+        // Taproot script path signatures
+        if (!input.m_tap_script_sigs.empty()) {
+            UniValue script_sigs(UniValue::VARR);
+            for (const auto& [pubkey_leaf, sig] : input.m_tap_script_sigs) {
+                const auto& [xonly, leaf_hash] = pubkey_leaf;
+                UniValue sigobj(UniValue::VOBJ);
+                sigobj.pushKV("pubkey", HexStr(xonly));
+                sigobj.pushKV("leaf_hash", HexStr(leaf_hash));
+                sigobj.pushKV("sig", HexStr(sig));
+                script_sigs.push_back(sigobj);
+            }
+            in.pushKV("taproot_script_path_sigs", script_sigs);
+        }
+
+        // Taproot leaf scripts
+        if (!input.m_tap_scripts.empty()) {
+            UniValue tap_scripts(UniValue::VARR);
+            for (const auto& [leaf, control_blocks] : input.m_tap_scripts) {
+                const auto& [script, leaf_ver] = leaf;
+                UniValue script_info(UniValue::VOBJ);
+                script_info.pushKV("script", HexStr(script));
+                script_info.pushKV("leaf_ver", leaf_ver);
+                UniValue control_blocks_univ(UniValue::VARR);
+                for (const auto& control_block : control_blocks) {
+                    control_blocks_univ.push_back(HexStr(control_block));
+                }
+                script_info.pushKV("control_blocks", control_blocks_univ);
+                tap_scripts.push_back(script_info);
+            }
+            in.pushKV("taproot_scripts", tap_scripts);
+        }
+
+        // Taproot bip32 keypaths
+        if (!input.m_tap_bip32_paths.empty()) {
+            UniValue keypaths(UniValue::VARR);
+            for (const auto& [xonly, leaf_origin] : input.m_tap_bip32_paths) {
+                const auto& [leaf_hashes, origin] = leaf_origin;
+                UniValue path_obj(UniValue::VOBJ);
+                path_obj.pushKV("pubkey", HexStr(xonly));
+                path_obj.pushKV("master_fingerprint", strprintf("%08x", ReadBE32(origin.fingerprint)));
+                path_obj.pushKV("path", WriteHDKeypath(origin.path));
+                UniValue leaf_hashes_arr(UniValue::VARR);
+                for (const auto& leaf_hash : leaf_hashes) {
+                    leaf_hashes_arr.push_back(HexStr(leaf_hash));
+                }
+                path_obj.pushKV("leaf_hashes", leaf_hashes_arr);
+                keypaths.push_back(path_obj);
+            }
+            in.pushKV("taproot_bip32_derivs", keypaths);
+        }
+
+        // Taproot internal key
+        if (!input.m_tap_internal_key.IsNull()) {
+            in.pushKV("taproot_internal_key", HexStr(input.m_tap_internal_key));
+        }
+
+        // Write taproot merkle root
+        if (!input.m_tap_merkle_root.IsNull()) {
+            in.pushKV("taproot_merkle_root", HexStr(input.m_tap_merkle_root));
+        }
+
         // Proprietary
         if (!input.m_proprietary.empty()) {
             UniValue proprietary(UniValue::VARR);
@@ -1103,6 +1229,47 @@ static RPCHelpMan decodepsbt()
             out.pushKV("bip32_derivs", keypaths);
         }
 
+        // Taproot internal key
+        if (!output.m_tap_internal_key.IsNull()) {
+            out.pushKV("taproot_internal_key", HexStr(output.m_tap_internal_key));
+        }
+
+        // Taproot tree
+        if (!output.m_tap_tree.IsEmpty()) {
+            UniValue tree(UniValue::VARR);
+            const auto& tuples = output.m_tap_tree.GetTreeTuples();
+            for (const auto& tuple : tuples) {
+                uint8_t depth = std::get<0>(tuple);
+                uint8_t leaf_ver = std::get<1>(tuple);
+                CScript script = std::get<2>(tuple);
+                UniValue elem(UniValue::VOBJ);
+                elem.pushKV("depth", (int)depth);
+                elem.pushKV("leaf_ver", (int)leaf_ver);
+                elem.pushKV("script", HexStr(script));
+                tree.push_back(elem);
+            }
+            out.pushKV("taproot_tree", tree);
+        }
+
+        // Taproot bip32 keypaths
+        if (!output.m_tap_bip32_paths.empty()) {
+            UniValue keypaths(UniValue::VARR);
+            for (const auto& [xonly, leaf_origin] : output.m_tap_bip32_paths) {
+                const auto& [leaf_hashes, origin] = leaf_origin;
+                UniValue path_obj(UniValue::VOBJ);
+                path_obj.pushKV("pubkey", HexStr(xonly));
+                path_obj.pushKV("master_fingerprint", strprintf("%08x", ReadBE32(origin.fingerprint)));
+                path_obj.pushKV("path", WriteHDKeypath(origin.path));
+                UniValue leaf_hashes_arr(UniValue::VARR);
+                for (const auto& leaf_hash : leaf_hashes) {
+                    leaf_hashes_arr.push_back(HexStr(leaf_hash));
+                }
+                path_obj.pushKV("leaf_hashes", leaf_hashes_arr);
+                keypaths.push_back(path_obj);
+            }
+            out.pushKV("taproot_bip32_derivs", keypaths);
+        }
+
         // Proprietary
         if (!output.m_proprietary.empty()) {
             UniValue proprietary(UniValue::VARR);
-- 
2.36.1


From 689d17536b07b91551b936b3f1deaad70d9938dc Mon Sep 17 00:00:00 2001
From: Andrew Chow <achow101-github@achow101.com>
Date: Tue, 20 Jul 2021 20:04:33 -0400
Subject: [PATCH 11/48] psbt: Remove non_witness_utxo for segwit v1+

If all inputs are segwit v1+, the non_witness_utxos can be removed.
---
 src/psbt.cpp          |  6 +++---
 src/wallet/wallet.cpp | 29 +++++++++++++++++++++++++++++
 2 files changed, 32 insertions(+), 3 deletions(-)

diff --git a/src/psbt.cpp b/src/psbt.cpp
index 2b2070e66e..0c331de6e9 100644
--- a/src/psbt.cpp
+++ b/src/psbt.cpp
@@ -184,7 +184,6 @@ void PSBTInput::Merge(const PSBTInput& input)
 {
     if (!non_witness_utxo && input.non_witness_utxo) non_witness_utxo = input.non_witness_utxo;
     if (witness_utxo.IsNull() && !input.witness_utxo.IsNull()) {
-        // TODO: For segwit v1, we will want to clear out the non-witness utxo when setting a witness one. For v0 and non-segwit, this is not safe
         witness_utxo = input.witness_utxo;
     }
 
@@ -368,10 +367,11 @@ bool SignPSBTInput(const SigningProvider& provider, PartiallySignedTransaction&
     input.FromSignatureData(sigdata);
 
     // If we have a witness signature, put a witness UTXO.
-    // TODO: For segwit v1, we should remove the non_witness_utxo
     if (sigdata.witness) {
         input.witness_utxo = utxo;
-        // input.non_witness_utxo = nullptr;
+        // We can remove the non_witness_utxo if and only if there are no non-segwit or segwit v0
+        // inputs in this transaction. Since this requires inspecting the entire transaction, this
+        // is something for the caller to deal with (i.e. FillPSBT).
     }
 
     // Fill in the missing info
diff --git a/src/wallet/wallet.cpp b/src/wallet/wallet.cpp
index 6c333c709b..aafbf341ff 100644
--- a/src/wallet/wallet.cpp
+++ b/src/wallet/wallet.cpp
@@ -2015,6 +2015,35 @@ TransactionError CWallet::FillPSBT(PartiallySignedTransaction& psbtx, bool& comp
         }
     }
 
+    // Only drop non_witness_utxos if sighash_type != SIGHASH_ANYONECANPAY
+    if ((sighash_type & 0x80) != SIGHASH_ANYONECANPAY) {
+        // Figure out if any non_witness_utxos should be dropped
+        std::vector<unsigned int> to_drop;
+        for (unsigned int i = 0; i < psbtx.inputs.size(); ++i) {
+            const auto& input = psbtx.inputs.at(i);
+            int wit_ver;
+            std::vector<unsigned char> wit_prog;
+            if (input.witness_utxo.IsNull() || !input.witness_utxo.scriptPubKey.IsWitnessProgram(wit_ver, wit_prog)) {
+                // There's a non-segwit input or Segwit v0, so we cannot drop any witness_utxos
+                to_drop.clear();
+                break;
+            }
+            if (wit_ver == 0) {
+                // Segwit v0, so we cannot drop any non_witness_utxos
+                to_drop.clear();
+                break;
+            }
+            if (input.non_witness_utxo) {
+                to_drop.push_back(i);
+            }
+        }
+
+        // Drop the non_witness_utxos that we can drop
+        for (unsigned int i : to_drop) {
+            psbtx.inputs.at(i).non_witness_utxo = nullptr;
+        }
+    }
+
     // Complete if every input is now signed
     complete = true;
     for (const auto& input : psbtx.inputs) {
-- 
2.36.1


From e9d664eaa526ab4cbe1c57e90c3d74e8fde0bfeb Mon Sep 17 00:00:00 2001
From: Andrew Chow <achow101-github@achow101.com>
Date: Fri, 23 Jul 2021 18:50:54 -0400
Subject: [PATCH 12/48] tests: Test taproot fields for PSBT

---
 test/functional/data/rpc_psbt.json | 21 +++++++++++++++++++--
 1 file changed, 19 insertions(+), 2 deletions(-)

diff --git a/test/functional/data/rpc_psbt.json b/test/functional/data/rpc_psbt.json
index 8672400a92..430a1802a8 100644
--- a/test/functional/data/rpc_psbt.json
+++ b/test/functional/data/rpc_psbt.json
@@ -27,7 +27,18 @@
         "cHNidP8BADMBAAAAAREREREREREREREREREREREREfrK3hERERERERERERERfwAAAAD/////AAAAAAAAAQQAAQQBagA=",
         "cHNidP8BADMBAAAAAREREREREREREREREREREREREfrK3hERERERERERERERfwAAAAD/////AAAAAAAAAQEJAOH1BQAAAAAAAQUAAQUBUQA=",
         "cHNidP8BADMBAAAAAREREREREREREREREREREREREfrK3hERERERERERERERfwAAAAD/////AAAAAAAAAQcAAQcBUQA=",
-        "cHNidP8BADMBAAAAAREREREREREREREREREREREREfrK3hERERERERERERERfwAAAAD/////AAAAAAAAAQEJAOH1BQAAAAAAAQgBAAEIAwEBUQA="
+        "cHNidP8BADMBAAAAAREREREREREREREREREREREREfrK3hERERERERERERERfwAAAAD/////AAAAAAAAAQEJAOH1BQAAAAAAAQgBAAEIAwEBUQA=",
+        "cHNidP8BAHECAAAAASd0Srq/MCf+DWzyOpbu4u+xiO9SMBlUWFiD5ptmJLJCAAAAAAD/////Anh8AQAAAAAAFgAUg6fjS9mf8DpJYu+KGhAbspVGHs5gawQqAQAAABYAFHrDad8bIOAz1hFmI5V7CsSfPFLoAAAAAAABASsA8gUqAQAAACJRIFosLPW1LPMfg60ujaY/8DGD7Nj2CcdRCuikjgORCgdXARchAv40kGTJjW4qhT+jybEr2LMEoZwZXGDvp+4jkwRtP6IyAAAA",
+        "cHNidP8BAHECAAAAASd0Srq/MCf+DWzyOpbu4u+xiO9SMBlUWFiD5ptmJLJCAAAAAAD/////Anh8AQAAAAAAFgAUg6fjS9mf8DpJYu+KGhAbspVGHs5gawQqAQAAABYAFHrDad8bIOAz1hFmI5V7CsSfPFLoAAAAAAABASsA8gUqAQAAACJRIFosLPW1LPMfg60ujaY/8DGD7Nj2CcdRCuikjgORCgdXARM/Fzuz02wHSvtxb+xjB6BpouRQuZXzyCeFlFq43w4kJg3NcDsMvzTeOZGEqUgawrNYbbZgHwJqd/fkk4SBvDR1AAAA",
+        "cHNidP8BAHECAAAAASd0Srq/MCf+DWzyOpbu4u+xiO9SMBlUWFiD5ptmJLJCAAAAAAD/////Anh8AQAAAAAAFgAUg6fjS9mf8DpJYu+KGhAbspVGHs5gawQqAQAAABYAFHrDad8bIOAz1hFmI5V7CsSfPFLoAAAAAAABASsA8gUqAQAAACJRIFosLPW1LPMfg60ujaY/8DGD7Nj2CcdRCuikjgORCgdXARNCFzuz02wHSvtxb+xjB6BpouRQuZXzyCeFlFq43w4kJg3NcDsMvzTeOZGEqUgawrNYbbZgHwJqd/fkk4SBvDR1FwGqAAAA",
+        "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"
     ],
     "valid" : [
         "cHNidP8BAHUCAAAAASaBcTce3/KF6Tet7qSze3gADAVmy7OtZGQXE8pCFxv2AAAAAAD+////AtPf9QUAAAAAGXapFNDFmQPFusKGh2DpD9UhpGZap2UgiKwA4fUFAAAAABepFDVF5uM7gyxHBQ8k0+65PJwDlIvHh7MuEwAAAQD9pQEBAAAAAAECiaPHHqtNIOA3G7ukzGmPopXJRjr6Ljl/hTPMti+VZ+UBAAAAFxYAFL4Y0VKpsBIDna89p95PUzSe7LmF/////4b4qkOnHf8USIk6UwpyN+9rRgi7st0tAXHmOuxqSJC0AQAAABcWABT+Pp7xp0XpdNkCxDVZQ6vLNL1TU/////8CAMLrCwAAAAAZdqkUhc/xCX/Z4Ai7NK9wnGIZeziXikiIrHL++E4sAAAAF6kUM5cluiHv1irHU6m80GfWx6ajnQWHAkcwRAIgJxK+IuAnDzlPVoMR3HyppolwuAJf3TskAinwf4pfOiQCIAGLONfc0xTnNMkna9b7QPZzMlvEuqFEyADS8vAtsnZcASED0uFWdJQbrUqZY3LLh+GFbTZSYG2YVi/jnF6efkE/IQUCSDBFAiEA0SuFLYXc2WHS9fSrZgZU327tzHlMDDPOXMMJ/7X85Y0CIGczio4OFyXBl/saiK9Z9R5E5CVbIBZ8hoQDHAXR8lkqASECI7cr7vCWXRC+B3jv7NYfysb3mk6haTkzgHNEZPhPKrMAAAAAAAAA",
@@ -43,7 +54,13 @@
         "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",
-        "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"
+        "cHNidP8BAHUCAAAAASaBcTce3/KF6Tet7qSze3gADAVmy7OtZGQXE8pCFxv2AAAAAAD+////AtPf9QUAAAAAGXapFNDFmQPFusKGh2DpD9UhpGZap2UgiKwA4fUFAAAAABepFDVF5uM7gyxHBQ8k0+65PJwDlIvHh7MuEwAAAQD9pQEBAAAAAAECiaPHHqtNIOA3G7ukzGmPopXJRjr6Ljl/hTPMti+VZ+UBAAAAFxYAFL4Y0VKpsBIDna89p95PUzSe7LmF/////4b4qkOnHf8USIk6UwpyN+9rRgi7st0tAXHmOuxqSJC0AQAAABcWABT+Pp7xp0XpdNkCxDVZQ6vLNL1TU/////8CAMLrCwAAAAAZdqkUhc/xCX/Z4Ai7NK9wnGIZeziXikiIrHL++E4sAAAAF6kUM5cluiHv1irHU6m80GfWx6ajnQWHAkcwRAIgJxK+IuAnDzlPVoMR3HyppolwuAJf3TskAinwf4pfOiQCIAGLONfc0xTnNMkna9b7QPZzMlvEuqFEyADS8vAtsnZcASED0uFWdJQbrUqZY3LLh+GFbTZSYG2YVi/jnF6efkE/IQUCSDBFAiEA0SuFLYXc2WHS9fSrZgZU327tzHlMDDPOXMMJ/7X85Y0CIGczio4OFyXBl/saiK9Z9R5E5CVbIBZ8hoQDHAXR8lkqASECI7cr7vCWXRC+B3jv7NYfysb3mk6haTkzgHNEZPhPKrMAAAAAIQ12pWrO2RXSUT3NhMLDeLLoqlzWMrW3HKLyrFsOOmSb2wIBAiENnBLP3ATHRYTXh6w9I3chMsGFJLx6so3sQhm4/FtCX3ABAQAAAA==",
+        "cHNidP8BAFICAAAAASd0Srq/MCf+DWzyOpbu4u+xiO9SMBlUWFiD5ptmJLJCAAAAAAD/////AUjmBSoBAAAAFgAUdo4e60z0IIZgM/gKzv8PlyB0SWkAAAAAAAEBKwDyBSoBAAAAIlEgWiws9bUs8x+DrS6Npj/wMYPs2PYJx1EK6KSOA5EKB1chFv40kGTJjW4qhT+jybEr2LMEoZwZXGDvp+4jkwRtP6IyGQB3Ky2nVgAAgAEAAIAAAACAAQAAAAAAAAABFyD+NJBkyY1uKoU/o8mxK9izBKGcGVxg76fuI5MEbT+iMgAiAgNrdyptt02HU8mKgnlY3mx4qzMSEJ830+AwRIQkLs5z2Bh3Ky2nVAAAgAEAAIAAAACAAAAAAAAAAAAA",
+        "cHNidP8BAFICAAAAASd0Srq/MCf+DWzyOpbu4u+xiO9SMBlUWFiD5ptmJLJCAAAAAAD/////AUjmBSoBAAAAFgAUdo4e60z0IIZgM/gKzv8PlyB0SWkAAAAAAAEBKwDyBSoBAAAAIlEgWiws9bUs8x+DrS6Npj/wMYPs2PYJx1EK6KSOA5EKB1cBE0C7U+yRe62dkGrxuocYHEi4as5aritTYFpyXKdGJWMUdvxvW67a9PLuD0d/NvWPOXDVuCc7fkl7l68uPxJcl680IRb+NJBkyY1uKoU/o8mxK9izBKGcGVxg76fuI5MEbT+iMhkAdystp1YAAIABAACAAAAAgAEAAAAAAAAAARcg/jSQZMmNbiqFP6PJsSvYswShnBlcYO+n7iOTBG0/ojIAIgIDa3cqbbdNh1PJioJ5WN5seKszEhCfN9PgMESEJC7Oc9gYdystp1QAAIABAACAAAAAgAAAAAAAAAAAAA==",
+        "cHNidP8BAF4CAAAAASd0Srq/MCf+DWzyOpbu4u+xiO9SMBlUWFiD5ptmJLJCAAAAAAD/////AUjmBSoBAAAAIlEgg2mORYxmZOFZXXXaJZfeHiLul9eY5wbEwKS1qYI810MAAAAAAAEBKwDyBSoBAAAAIlEgWiws9bUs8x+DrS6Npj/wMYPs2PYJx1EK6KSOA5EKB1chFv40kGTJjW4qhT+jybEr2LMEoZwZXGDvp+4jkwRtP6IyGQB3Ky2nVgAAgAEAAIAAAACAAQAAAAAAAAABFyD+NJBkyY1uKoU/o8mxK9izBKGcGVxg76fuI5MEbT+iMgABBSARJNp67JLM0GyVRWJkf0N7E4uVchqEvivyJ2u92rPmcSEHESTaeuySzNBslUViZH9DexOLlXIahL4r8idrvdqz5nEZAHcrLadWAACAAQAAgAAAAIAAAAAABQAAAAA=",
+        "cHNidP8BAF4CAAAAAZvUh2UjC/mnLmYgAflyVW5U8Mb5f+tWvLVgDYF/aZUmAQAAAAD/////AUjmBSoBAAAAIlEgg2mORYxmZOFZXXXaJZfeHiLul9eY5wbEwKS1qYI810MAAAAAAAEBKwDyBSoBAAAAIlEgwiR++/2SrEf29AuNQtFpF1oZ+p+hDkol1/NetN2FtpJiFcFQkpt0waBJVLeLS2A16XpeB4paDyjsltVHv+6azoA6wG99YgWelJehpKJnVp2YdtpgEBr/OONSm5uTnOf5GulwEV8uSQr3zEXE94UR82BXzlxaXFYyWin7RN/CA/NW4fgjICyxOsaCSN6AaqajZZzzwD62gh0JyBFKToaP696GW7bSrMBCFcFQkpt0waBJVLeLS2A16XpeB4paDyjsltVHv+6azoA6wJfG5v6l/3FP9XJEmZkIEOQG6YqhD1v35fZ4S8HQqabOIyBDILC/FvARtT6nvmFZJKp/J+XSmtIOoRVdhIZ2w7rRsqzAYhXBUJKbdMGgSVS3i0tgNel6XgeKWg8o7JbVR7/ums6AOsDNlw4V9T/AyC+VD9Vg/6kZt2FyvgFzaKiZE68HT0ALCRFfLkkK98xFxPeFEfNgV85cWlxWMlop+0TfwgPzVuH4IyD6D3o87zsdDAps59JuF62gsuXJLRnvrUi0GFnLikUcqazAIRYssTrGgkjegGqmo2Wc88A+toIdCcgRSk6Gj+vehlu20jkBzZcOFfU/wMgvlQ/VYP+pGbdhcr4Bc2iomROvB09ACwl3Ky2nVgAAgAEAAIACAACAAAAAAAAAAAAhFkMgsL8W8BG1Pqe+YVkkqn8n5dKa0g6hFV2EhnbDutGyOQERXy5JCvfMRcT3hRHzYFfOXFpcVjJaKftE38ID81bh+HcrLadWAACAAQAAgAEAAIAAAAAAAAAAACEWUJKbdMGgSVS3i0tgNel6XgeKWg8o7JbVR7/ums6AOsAFAHxGHl0hFvoPejzvOx0MCmzn0m4XraCy5cktGe+tSLQYWcuKRRypOQFvfWIFnpSXoaSiZ1admHbaYBAa/zjjUpubk5zn+RrpcHcrLadWAACAAQAAgAMAAIAAAAAAAAAAAAEXIFCSm3TBoElUt4tLYDXpel4HiloPKOyW1Ue/7prOgDrAARgg8DYuL3Wm9CClvePrIh2WrmcgzyX4GJDJWx13WstRXmUAAQUgESTaeuySzNBslUViZH9DexOLlXIahL4r8idrvdqz5nEhBxEk2nrskszQbJVFYmR/Q3sTi5VyGoS+K/Ina73as+ZxGQB3Ky2nVgAAgAEAAIAAAACAAAAAAAUAAAAA",
+        "cHNidP8BAF4CAAAAASd0Srq/MCf+DWzyOpbu4u+xiO9SMBlUWFiD5ptmJLJCAAAAAAD/////AUjmBSoBAAAAIlEgCoy9yG3hzhwPnK6yLW33ztNoP+Qj4F0eQCqHk0HW9vUAAAAAAAEBKwDyBSoBAAAAIlEgWiws9bUs8x+DrS6Npj/wMYPs2PYJx1EK6KSOA5EKB1chFv40kGTJjW4qhT+jybEr2LMEoZwZXGDvp+4jkwRtP6IyGQB3Ky2nVgAAgAEAAIAAAACAAQAAAAAAAAABFyD+NJBkyY1uKoU/o8mxK9izBKGcGVxg76fuI5MEbT+iMgABBSBQkpt0waBJVLeLS2A16XpeB4paDyjsltVHv+6azoA6wAEGbwLAIiBzblcpAP4SUliaIUPI88efcaBBLSNTr3VelwHHgmlKAqwCwCIgYxxfO1gyuPvev7GXBM7rMjwh9A96JPQ9aO8MwmsSWWmsAcAiIET6pJoDON5IjI3//s37bzKfOAvVZu8gyN9tgT6rHEJzrCEHRPqkmgM43kiMjf/+zftvMp84C9Vm7yDI322BPqscQnM5AfBreYuSoQ7ZqdC7/Trxc6U7FhfaOkFZygCCFs2Fay4Odystp1YAAIABAACAAQAAgAAAAAADAAAAIQdQkpt0waBJVLeLS2A16XpeB4paDyjsltVHv+6azoA6wAUAfEYeXSEHYxxfO1gyuPvev7GXBM7rMjwh9A96JPQ9aO8MwmsSWWk5ARis5AmIl4Xg6nDO67jhyokqenjq7eDy4pbPQ1lhqPTKdystp1YAAIABAACAAgAAgAAAAAADAAAAIQdzblcpAP4SUliaIUPI88efcaBBLSNTr3VelwHHgmlKAjkBKaW0kVCQFi11mv0/4Pk/ozJgVtC0CIy5M8rngmy42Cx3Ky2nVgAAgAEAAIADAACAAAAAAAMAAAAA",
+        "cHNidP8BAF4CAAAAAZvUh2UjC/mnLmYgAflyVW5U8Mb5f+tWvLVgDYF/aZUmAQAAAAD/////AUjmBSoBAAAAIlEgg2mORYxmZOFZXXXaJZfeHiLul9eY5wbEwKS1qYI810MAAAAAAAEBKwDyBSoBAAAAIlEgwiR++/2SrEf29AuNQtFpF1oZ+p+hDkol1/NetN2FtpJBFCyxOsaCSN6AaqajZZzzwD62gh0JyBFKToaP696GW7bSzZcOFfU/wMgvlQ/VYP+pGbdhcr4Bc2iomROvB09ACwlAv4GNl1fW/+tTi6BX+0wfxOD17xhudlvrVkeR4Cr1/T1eJVHU404z2G8na4LJnHmu0/A5Wgge/NLMLGXdfmk9eUEUQyCwvxbwEbU+p75hWSSqfyfl0prSDqEVXYSGdsO60bIRXy5JCvfMRcT3hRHzYFfOXFpcVjJaKftE38ID81bh+EDh8atvq/omsjbyGDNxncHUKKt2jYD5H5mI2KvvR7+4Y7sfKlKfdowV8AzjTsKDzcB+iPhCi+KPbvZAQ8MpEYEaQRT6D3o87zsdDAps59JuF62gsuXJLRnvrUi0GFnLikUcqW99YgWelJehpKJnVp2YdtpgEBr/OONSm5uTnOf5GulwQOwfA3kgZGHIM0IoVCMyZwirAx8NpKJT7kWq+luMkgNNi2BUkPjNE+APmJmJuX4hX6o28S3uNpPS2szzeBwXV/ZiFcFQkpt0waBJVLeLS2A16XpeB4paDyjsltVHv+6azoA6wG99YgWelJehpKJnVp2YdtpgEBr/OONSm5uTnOf5GulwEV8uSQr3zEXE94UR82BXzlxaXFYyWin7RN/CA/NW4fgjICyxOsaCSN6AaqajZZzzwD62gh0JyBFKToaP696GW7bSrMBCFcFQkpt0waBJVLeLS2A16XpeB4paDyjsltVHv+6azoA6wJfG5v6l/3FP9XJEmZkIEOQG6YqhD1v35fZ4S8HQqabOIyBDILC/FvARtT6nvmFZJKp/J+XSmtIOoRVdhIZ2w7rRsqzAYhXBUJKbdMGgSVS3i0tgNel6XgeKWg8o7JbVR7/ums6AOsDNlw4V9T/AyC+VD9Vg/6kZt2FyvgFzaKiZE68HT0ALCRFfLkkK98xFxPeFEfNgV85cWlxWMlop+0TfwgPzVuH4IyD6D3o87zsdDAps59JuF62gsuXJLRnvrUi0GFnLikUcqazAIRYssTrGgkjegGqmo2Wc88A+toIdCcgRSk6Gj+vehlu20jkBzZcOFfU/wMgvlQ/VYP+pGbdhcr4Bc2iomROvB09ACwl3Ky2nVgAAgAEAAIACAACAAAAAAAAAAAAhFkMgsL8W8BG1Pqe+YVkkqn8n5dKa0g6hFV2EhnbDutGyOQERXy5JCvfMRcT3hRHzYFfOXFpcVjJaKftE38ID81bh+HcrLadWAACAAQAAgAEAAIAAAAAAAAAAACEWUJKbdMGgSVS3i0tgNel6XgeKWg8o7JbVR7/ums6AOsAFAHxGHl0hFvoPejzvOx0MCmzn0m4XraCy5cktGe+tSLQYWcuKRRypOQFvfWIFnpSXoaSiZ1admHbaYBAa/zjjUpubk5zn+RrpcHcrLadWAACAAQAAgAMAAIAAAAAAAAAAAAEXIFCSm3TBoElUt4tLYDXpel4HiloPKOyW1Ue/7prOgDrAARgg8DYuL3Wm9CClvePrIh2WrmcgzyX4GJDJWx13WstRXmUAAQUgESTaeuySzNBslUViZH9DexOLlXIahL4r8idrvdqz5nEhBxEk2nrskszQbJVFYmR/Q3sTi5VyGoS+K/Ina73as+ZxGQB3Ky2nVgAAgAEAAIAAAACAAAAAAAUAAAAA"
     ],
     "creator" : [
         {
-- 
2.36.1


From 9ac1a734153c666b85de9d1b4a18d804530ad465 Mon Sep 17 00:00:00 2001
From: Andrew Chow <achow101-github@achow101.com>
Date: Mon, 26 Jul 2021 16:23:50 -0400
Subject: [PATCH 13/48] taproot: Use pre-existing signatures if available

Actually use pre-existing signatures in CreateTaprootScriptSig if a
signature is found for the given key and leaf hash.
---
 src/script/sign.cpp               | 1 +
 test/functional/wallet_taproot.py | 3 +--
 2 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/src/script/sign.cpp b/src/script/sign.cpp
index 5cd773f6ee..12f2ec4d3a 100644
--- a/src/script/sign.cpp
+++ b/src/script/sign.cpp
@@ -150,6 +150,7 @@ static bool CreateTaprootScriptSig(const BaseSignatureCreator& creator, Signatur
     auto it = sigdata.taproot_script_sigs.find(lookup_key);
     if (it != sigdata.taproot_script_sigs.end()) {
         sig_out = it->second;
+        return true;
     }
     if (creator.CreateSchnorrSig(provider, sig_out, pubkey, &leaf_hash, nullptr, sigversion)) {
         sigdata.taproot_script_sigs[lookup_key] = sig_out;
diff --git a/test/functional/wallet_taproot.py b/test/functional/wallet_taproot.py
index a4d836c8fe..da8fa6fe03 100755
--- a/test/functional/wallet_taproot.py
+++ b/test/functional/wallet_taproot.py
@@ -446,8 +446,7 @@ class WalletTaprootTest(BitcoinTestFramework):
         assert(self.rpc_online.gettransaction(txid)["confirmations"] > 0)
 
         psbt = self.psbt_online.sendall(recipients=[self.boring.getnewaddress()], options={"psbt": True})["psbt"]
-        res = self.psbt_offline.walletprocesspsbt(psbt)
-        assert(res['complete'])
+        res = self.psbt_offline.walletprocesspsbt(psbt=psbt, finalize=False)
         rawtx = self.nodes[0].finalizepsbt(res['psbt'])['hex']
         txid = self.nodes[0].sendrawtransaction(rawtx)
         self.generatetoaddress(self.nodes[0], 1, self.boring.getnewaddress(), sync_fun=self.no_op)
-- 
2.36.1


From 722b12006b46fb3a8bcf2ab6d4f506f203f85d92 Mon Sep 17 00:00:00 2001
From: Andrew Chow <achow101-github@achow101.com>
Date: Mon, 26 Jul 2021 16:25:42 -0400
Subject: [PATCH 14/48] psbt, test: Check for taproot fields in taproot psbt
 test

---
 test/functional/wallet_taproot.py | 18 +++++++++++++++---
 1 file changed, 15 insertions(+), 3 deletions(-)

diff --git a/test/functional/wallet_taproot.py b/test/functional/wallet_taproot.py
index da8fa6fe03..6218647f17 100755
--- a/test/functional/wallet_taproot.py
+++ b/test/functional/wallet_taproot.py
@@ -305,9 +305,21 @@ class WalletTaprootTest(BitcoinTestFramework):
             test_balance = int(self.psbt_online.getbalance() * 100000000)
             ret_amnt = random.randrange(100000, test_balance)
             # Increase fee_rate to compensate for the wallet's inability to estimate fees for script path spends.
-            psbt = self.psbt_online.walletcreatefundedpsbt([], [{self.boring.getnewaddress(): Decimal(ret_amnt) / 100000000}], None, {"subtractFeeFromOutputs":[0], "fee_rate": 200})['psbt']
-            res = self.psbt_offline.walletprocesspsbt(psbt)
-            assert(res['complete'])
+            psbt = self.psbt_online.walletcreatefundedpsbt([], [{self.boring.getnewaddress(): Decimal(ret_amnt) / 100000000}], None, {"subtractFeeFromOutputs":[0], "fee_rate": 200, "change_type": "bech32m"})['psbt']
+            res = self.psbt_offline.walletprocesspsbt(psbt=psbt, finalize=False)
+
+            decoded = self.psbt_offline.decodepsbt(res["psbt"])
+            if pattern.startswith("tr("):
+                for psbtin in decoded["inputs"]:
+                    assert "non_witness_utxo" not in psbtin
+                    assert "witness_utxo" in psbtin
+                    assert "taproot_internal_key" in psbtin
+                    assert "taproot_bip32_derivs" in psbtin
+                    assert "taproot_key_path_sig" in psbtin or "taproot_script_path_sigs" in psbtin
+                    if "taproot_script_path_sigs" in psbtin:
+                        assert "taproot_merkle_root" in psbtin
+                        assert "taproot_scripts" in psbtin
+
             rawtx = self.nodes[0].finalizepsbt(res['psbt'])['hex']
             txid = self.nodes[0].sendrawtransaction(rawtx)
             self.generatetoaddress(self.nodes[0], 1, self.boring.getnewaddress(), sync_fun=self.no_op)
-- 
2.36.1


From a29f6051a8e60db7218a8139b83645f1cc6d8610 Mon Sep 17 00:00:00 2001
From: Andrew Chow <achow101-github@achow101.com>
Date: Wed, 24 Nov 2021 22:50:10 -0500
Subject: [PATCH 15/48] psbt: Implement merge for Taproot fields

---
 src/psbt.cpp | 9 +++++++++
 1 file changed, 9 insertions(+)

diff --git a/src/psbt.cpp b/src/psbt.cpp
index 0c331de6e9..d038fced08 100644
--- a/src/psbt.cpp
+++ b/src/psbt.cpp
@@ -194,11 +194,17 @@ void PSBTInput::Merge(const PSBTInput& input)
     hash256_preimages.insert(input.hash256_preimages.begin(), input.hash256_preimages.end());
     hd_keypaths.insert(input.hd_keypaths.begin(), input.hd_keypaths.end());
     unknown.insert(input.unknown.begin(), input.unknown.end());
+    m_tap_script_sigs.insert(input.m_tap_script_sigs.begin(), input.m_tap_script_sigs.end());
+    m_tap_scripts.insert(input.m_tap_scripts.begin(), input.m_tap_scripts.end());
+    m_tap_bip32_paths.insert(input.m_tap_bip32_paths.begin(), input.m_tap_bip32_paths.end());
 
     if (redeem_script.empty() && !input.redeem_script.empty()) redeem_script = input.redeem_script;
     if (witness_script.empty() && !input.witness_script.empty()) witness_script = input.witness_script;
     if (final_script_sig.empty() && !input.final_script_sig.empty()) final_script_sig = input.final_script_sig;
     if (final_script_witness.IsNull() && !input.final_script_witness.IsNull()) final_script_witness = input.final_script_witness;
+    if (m_tap_key_sig.empty() && !input.m_tap_key_sig.empty()) m_tap_key_sig = input.m_tap_key_sig;
+    if (m_tap_internal_key.IsNull() && !input.m_tap_internal_key.IsNull()) m_tap_internal_key = input.m_tap_internal_key;
+    if (m_tap_merkle_root.IsNull() && !input.m_tap_merkle_root.IsNull()) m_tap_merkle_root = input.m_tap_merkle_root;
 }
 
 void PSBTOutput::FillSignatureData(SignatureData& sigdata) const
@@ -255,9 +261,12 @@ void PSBTOutput::Merge(const PSBTOutput& output)
 {
     hd_keypaths.insert(output.hd_keypaths.begin(), output.hd_keypaths.end());
     unknown.insert(output.unknown.begin(), output.unknown.end());
+    m_tap_bip32_paths.insert(output.m_tap_bip32_paths.begin(), output.m_tap_bip32_paths.end());
 
     if (redeem_script.empty() && !output.redeem_script.empty()) redeem_script = output.redeem_script;
     if (witness_script.empty() && !output.witness_script.empty()) witness_script = output.witness_script;
+    if (m_tap_internal_key.IsNull() && !output.m_tap_internal_key.IsNull()) m_tap_internal_key = output.m_tap_internal_key;
+    if (m_tap_tree.IsEmpty() && !output.m_tap_tree.IsEmpty()) m_tap_tree = output.m_tap_tree;
 }
 bool PSBTInputSigned(const PSBTInput& input)
 {
-- 
2.36.1


From cf3f0dfdc64c1e8b8c3c2ce0218f54865a5224d8 Mon Sep 17 00:00:00 2001
From: Andrew Chow <achow101-github@achow101.com>
Date: Mon, 2 May 2022 11:28:49 -0400
Subject: [PATCH 16/48] sign: Use sigdata taproot spenddata when signing

The taproot spenddata stored in a sigdata is the combination of data
existing previously (e.g. in a PSBT) and the data stored in a
SigningProvider. In order to use the external data when signing, we need
to be using the sigdata's spenddata.
---
 src/script/sign.cpp | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/src/script/sign.cpp b/src/script/sign.cpp
index 12f2ec4d3a..a3681d26cc 100644
--- a/src/script/sign.cpp
+++ b/src/script/sign.cpp
@@ -230,16 +230,16 @@ static bool SignTaproot(const SigningProvider& provider, const BaseSignatureCrea
     // Try key path spending.
     {
         KeyOriginInfo info;
-        if (provider.GetKeyOriginByXOnly(spenddata.internal_key, info)) {
-            auto it = sigdata.taproot_misc_pubkeys.find(spenddata.internal_key);
+        if (provider.GetKeyOriginByXOnly(sigdata.tr_spenddata.internal_key, info)) {
+            auto it = sigdata.taproot_misc_pubkeys.find(sigdata.tr_spenddata.internal_key);
             if (it == sigdata.taproot_misc_pubkeys.end()) {
-                sigdata.taproot_misc_pubkeys.emplace(spenddata.internal_key, std::make_pair(std::set<uint256>(), info));
+                sigdata.taproot_misc_pubkeys.emplace(sigdata.tr_spenddata.internal_key, std::make_pair(std::set<uint256>(), info));
             }
         }
 
         std::vector<unsigned char> sig;
         if (sigdata.taproot_key_path_sig.size() == 0) {
-            if (creator.CreateSchnorrSig(provider, sig, spenddata.internal_key, nullptr, &spenddata.merkle_root, SigVersion::TAPROOT)) {
+            if (creator.CreateSchnorrSig(provider, sig, sigdata.tr_spenddata.internal_key, nullptr, &sigdata.tr_spenddata.merkle_root, SigVersion::TAPROOT)) {
                 sigdata.taproot_key_path_sig = sig;
             }
         }
-- 
2.36.1


From c966eb2aceeee6dbce861fb8799cc29782d0f1b6 Mon Sep 17 00:00:00 2001
From: Andrew Chow <achow101-github@achow101.com>
Date: Mon, 2 May 2022 11:30:03 -0400
Subject: [PATCH 17/48] wallet: also search taproot pubkeys in FillPSBT

When filling a PSBT, we search the listed pubkeys in order to determine
whether the current DescriptorScriptPubKeyMan could sign the transaction
even if it is not watching the scripts. With Taproot, the taproot
pubkeys need to be searched as well.
---
 src/wallet/scriptpubkeyman.cpp | 13 +++++++++++++
 1 file changed, 13 insertions(+)

diff --git a/src/wallet/scriptpubkeyman.cpp b/src/wallet/scriptpubkeyman.cpp
index 8633e7c62c..1fec82a485 100644
--- a/src/wallet/scriptpubkeyman.cpp
+++ b/src/wallet/scriptpubkeyman.cpp
@@ -2180,6 +2180,19 @@ TransactionError DescriptorScriptPubKeyMan::FillPSBT(PartiallySignedTransaction&
                     *keys = Merge(*keys, *pk_keys);
                 }
             }
+            for (const auto& pk_pair : input.m_tap_bip32_paths) {
+                const XOnlyPubKey& pubkey = pk_pair.first;
+                for (unsigned char prefix : {0x02, 0x03}) {
+                    unsigned char b[33] = {prefix};
+                    std::copy(pubkey.begin(), pubkey.end(), b + 1);
+                    CPubKey fullpubkey;
+                    fullpubkey.Set(b, b + 33);
+                    std::unique_ptr<FlatSigningProvider> pk_keys = GetSigningProvider(fullpubkey);
+                    if (pk_keys) {
+                        *keys = Merge(*keys, *pk_keys);
+                    }
+                }
+            }
         }
 
         SignPSBTInput(HidingSigningProvider(keys.get(), !sign, !bip32derivs), psbtx, i, &txdata, sighash_type, nullptr, finalize);
-- 
2.36.1


From e0e8bd528b6a2a309e87f0e67efb9b573ae488e0 Mon Sep 17 00:00:00 2001
From: Andrew Chow <achow101-github@achow101.com>
Date: Mon, 4 Jan 2021 15:20:02 -0500
Subject: [PATCH 18/48] Define psbtv2 field numbers

---
 src/psbt.h | 12 ++++++++++++
 1 file changed, 12 insertions(+)

diff --git a/src/psbt.h b/src/psbt.h
index 13e6a787ca..5086c165b1 100644
--- a/src/psbt.h
+++ b/src/psbt.h
@@ -24,6 +24,11 @@ static constexpr uint8_t PSBT_MAGIC_BYTES[5] = {'p', 's', 'b', 't', 0xff};
 // Global types
 static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;
 static constexpr uint8_t PSBT_GLOBAL_XPUB = 0x01;
+static constexpr uint8_t PSBT_GLOBAL_TX_VERSION = 0x02;
+static constexpr uint8_t PSBT_GLOBAL_FALLBACK_LOCKTIME = 0x03;
+static constexpr uint8_t PSBT_GLOBAL_INPUT_COUNT = 0x04;
+static constexpr uint8_t PSBT_GLOBAL_OUTPUT_COUNT = 0x05;
+static constexpr uint8_t PSBT_GLOBAL_TX_MODIFIABLE = 0x06;
 static constexpr uint8_t PSBT_GLOBAL_VERSION = 0xFB;
 static constexpr uint8_t PSBT_GLOBAL_PROPRIETARY = 0xFC;
 
@@ -41,6 +46,11 @@ static constexpr uint8_t PSBT_IN_RIPEMD160 = 0x0A;
 static constexpr uint8_t PSBT_IN_SHA256 = 0x0B;
 static constexpr uint8_t PSBT_IN_HASH160 = 0x0C;
 static constexpr uint8_t PSBT_IN_HASH256 = 0x0D;
+static constexpr uint8_t PSBT_IN_PREVIOUS_TXID = 0x0e;
+static constexpr uint8_t PSBT_IN_OUTPUT_INDEX = 0x0f;
+static constexpr uint8_t PSBT_IN_SEQUENCE = 0x10;
+static constexpr uint8_t PSBT_IN_REQUIRED_TIME_LOCKTIME = 0x11;
+static constexpr uint8_t PSBT_IN_REQUIRED_HEIGHT_LOCKTIME = 0x12;
 static constexpr uint8_t PSBT_IN_TAP_KEY_SIG = 0x13;
 static constexpr uint8_t PSBT_IN_TAP_SCRIPT_SIG = 0x14;
 static constexpr uint8_t PSBT_IN_TAP_LEAF_SCRIPT = 0x15;
@@ -53,6 +63,8 @@ static constexpr uint8_t PSBT_IN_PROPRIETARY = 0xFC;
 static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;
 static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;
 static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;
+static constexpr uint8_t PSBT_OUT_AMOUNT = 0x03;
+static constexpr uint8_t PSBT_OUT_SCRIPT = 0x04;
 static constexpr uint8_t PSBT_OUT_TAP_INTERNAL_KEY = 0x05;
 static constexpr uint8_t PSBT_OUT_TAP_TREE = 0x06;
 static constexpr uint8_t PSBT_OUT_TAP_BIP32_DERIVATION = 0x07;
-- 
2.36.1


From acff05e0768120a1a45effd892b9fc4a3ef970dd Mon Sep 17 00:00:00 2001
From: Andrew Chow <achow101-github@achow101.com>
Date: Mon, 4 Jan 2021 16:56:36 -0500
Subject: [PATCH 19/48] Change PSBT unknown fields test to use higher numbers

Previously these tests were using 0x0f as the field number. Changed to
use 0xf0 instead as it is unlikely we will hit that anytime soon.
---
 test/functional/data/rpc_psbt.json | 6 +++---
 test/functional/rpc_psbt.py        | 2 +-
 2 files changed, 4 insertions(+), 4 deletions(-)

diff --git a/test/functional/data/rpc_psbt.json b/test/functional/data/rpc_psbt.json
index 430a1802a8..19b62b6125 100644
--- a/test/functional/data/rpc_psbt.json
+++ b/test/functional/data/rpc_psbt.json
@@ -144,10 +144,10 @@
         },
         {
             "combine" : [
-                "cHNidP8BAD8CAAAAAf//////////////////////////////////////////AAAAAAD/////AQAAAAAAAAAAA2oBAAAAAAAKDwECAwQFBgcICQ8BAgMEBQYHCAkKCwwNDg8ACg8BAgMEBQYHCAkPAQIDBAUGBwgJCgsMDQ4PAAoPAQIDBAUGBwgJDwECAwQFBgcICQoLDA0ODwA=",
-                "cHNidP8BAD8CAAAAAf//////////////////////////////////////////AAAAAAD/////AQAAAAAAAAAAA2oBAAAAAAAKDwECAwQFBgcIEA8BAgMEBQYHCAkKCwwNDg8ACg8BAgMEBQYHCBAPAQIDBAUGBwgJCgsMDQ4PAAoPAQIDBAUGBwgQDwECAwQFBgcICQoLDA0ODwA="
+                "cHNidP8BAD8CAAAAAf//////////////////////////////////////////AAAAAAD/////AQAAAAAAAAAAA2oBAAAAAAAK8AECAwQFBgcICQ8BAgMEBQYHCAkKCwwNDg8ACvABAgMEBQYHCAkPAQIDBAUGBwgJCgsMDQ4PAArwAQIDBAUGBwgJDwECAwQFBgcICQoLDA0ODwA=",
+                "cHNidP8BAD8CAAAAAf//////////////////////////////////////////AAAAAAD/////AQAAAAAAAAAAA2oBAAAAAAAK8AECAwQFBgcIEA8BAgMEBQYHCAkKCwwNDg8ACvABAgMEBQYHCBAPAQIDBAUGBwgJCgsMDQ4PAArwAQIDBAUGBwgQDwECAwQFBgcICQoLDA0ODwA="
             ],
-            "result" : "cHNidP8BAD8CAAAAAf//////////////////////////////////////////AAAAAAD/////AQAAAAAAAAAAA2oBAAAAAAAKDwECAwQFBgcICQ8BAgMEBQYHCAkKCwwNDg8KDwECAwQFBgcIEA8BAgMEBQYHCAkKCwwNDg8ACg8BAgMEBQYHCAkPAQIDBAUGBwgJCgsMDQ4PCg8BAgMEBQYHCBAPAQIDBAUGBwgJCgsMDQ4PAAoPAQIDBAUGBwgJDwECAwQFBgcICQoLDA0ODwoPAQIDBAUGBwgQDwECAwQFBgcICQoLDA0ODwA="
+            "result" : "cHNidP8BAD8CAAAAAf//////////////////////////////////////////AAAAAAD/////AQAAAAAAAAAAA2oBAAAAAAAK8AECAwQFBgcICQ8BAgMEBQYHCAkKCwwNDg8K8AECAwQFBgcIEA8BAgMEBQYHCAkKCwwNDg8ACvABAgMEBQYHCAkPAQIDBAUGBwgJCgsMDQ4PCvABAgMEBQYHCBAPAQIDBAUGBwgJCgsMDQ4PAArwAQIDBAUGBwgJDwECAwQFBgcICQoLDA0ODwrwAQIDBAUGBwgQDwECAwQFBgcICQoLDA0ODwA="
         }
     ],
     "finalizer" : [
diff --git a/test/functional/rpc_psbt.py b/test/functional/rpc_psbt.py
index 444e56610e..d00135c835 100755
--- a/test/functional/rpc_psbt.py
+++ b/test/functional/rpc_psbt.py
@@ -427,7 +427,7 @@ class PSBTTest(BitcoinTestFramework):
         # BIP 174 Test Vectors
 
         # Check that unknown values are just passed through
-        unknown_psbt = "cHNidP8BAD8CAAAAAf//////////////////////////////////////////AAAAAAD/////AQAAAAAAAAAAA2oBAAAAAAAACg8BAgMEBQYHCAkPAQIDBAUGBwgJCgsMDQ4PAAA="
+        unknown_psbt = "cHNidP8BAD8CAAAAAf//////////////////////////////////////////AAAAAAD/////AQAAAAAAAAAAA2oBAAAAAAAACvABAgMEBQYHCAkPAQIDBAUGBwgJCgsMDQ4PAAA="
         unknown_out = self.nodes[0].walletprocesspsbt(unknown_psbt)['psbt']
         assert_equal(unknown_psbt, unknown_out)
 
-- 
2.36.1


From 1f2da61adafd75e783f89c8293d8e82e4bba1594 Mon Sep 17 00:00:00 2001
From: Andrew Chow <achow101-github@achow101.com>
Date: Mon, 4 Jan 2021 16:07:25 -0500
Subject: [PATCH 20/48] Implement PSBTv2 fields de/ser

---
 src/psbt.h      | 222 +++++++++++++++++++++++++++++++++++++++++++++++-
 src/serialize.h |  13 +++
 2 files changed, 231 insertions(+), 4 deletions(-)

diff --git a/src/psbt.h b/src/psbt.h
index 5086c165b1..6eff336806 100644
--- a/src/psbt.h
+++ b/src/psbt.h
@@ -15,8 +15,10 @@
 #include <script/signingprovider.h>
 #include <span.h>
 #include <streams.h>
+#include <uint256.h>
 
 #include <optional>
+#include <bitset>
 
 // Magic bytes
 static constexpr uint8_t PSBT_MAGIC_BYTES[5] = {'p', 's', 'b', 't', 0xff};
@@ -216,6 +218,12 @@ struct PSBTInput
     std::map<uint160, std::vector<unsigned char>> hash160_preimages;
     std::map<uint256, std::vector<unsigned char>> hash256_preimages;
 
+    uint256 prev_txid;
+    std::optional<uint32_t> prev_out;
+    std::optional<uint32_t> sequence;
+    std::optional<uint32_t> time_locktime;
+    std::optional<uint32_t> height_locktime;
+
     // Taproot fields
     std::vector<unsigned char> m_tap_key_sig;
     std::map<std::pair<XOnlyPubKey, uint256>, std::vector<unsigned char>> m_tap_script_sigs;
@@ -358,6 +366,28 @@ struct PSBTInput
             SerializeToVector(s, final_script_witness.stack);
         }
 
+        // Write prev txid, vout, sequence, and lock times
+        if (!prev_txid.IsNull()) {
+            SerializeToVector(s, CompactSizeWriter(PSBT_IN_PREVIOUS_TXID));
+            SerializeToVector(s, prev_txid);
+        }
+        if (prev_out != std::nullopt) {
+            SerializeToVector(s, CompactSizeWriter(PSBT_IN_OUTPUT_INDEX));
+            SerializeToVector(s, *prev_out);
+        }
+        if (sequence != std::nullopt) {
+            SerializeToVector(s, CompactSizeWriter(PSBT_IN_SEQUENCE));
+            SerializeToVector(s, *sequence);
+        }
+        if (time_locktime != std::nullopt) {
+            SerializeToVector(s, CompactSizeWriter(PSBT_IN_REQUIRED_TIME_LOCKTIME));
+            SerializeToVector(s, *time_locktime);
+        }
+        if (height_locktime != std::nullopt) {
+            SerializeToVector(s, CompactSizeWriter(PSBT_IN_REQUIRED_HEIGHT_LOCKTIME));
+            SerializeToVector(s, *height_locktime);
+        }
+
         // Write proprietary things
         for (const auto& entry : m_proprietary) {
             s << entry.key;
@@ -581,6 +611,64 @@ struct PSBTInput
                     hash256_preimages.emplace(hash, std::move(preimage));
                     break;
                 }
+                case PSBT_IN_PREVIOUS_TXID:
+                {
+                    if (!key_lookup.emplace(key).second) {
+                        throw std::ios_base::failure("Duplicate Key, previous txid is already provided");
+                    } else if (key.size() != 1) {
+                        throw std::ios_base::failure("Previous txid key is more than one byte type");
+                    }
+                    UnserializeFromVector(s, prev_txid);
+                    break;
+                }
+                case PSBT_IN_OUTPUT_INDEX:
+                {
+                    if (!key_lookup.emplace(key).second) {
+                        throw std::ios_base::failure("Duplicate Key, previous output's index is already provided");
+                    } else if (key.size() != 1) {
+                        throw std::ios_base::failure("Previous output's index is more than one byte type");
+                    }
+                    uint32_t v;
+                    UnserializeFromVector(s, v);
+                    prev_out = v;
+                    break;
+                }
+                case PSBT_IN_SEQUENCE:
+                {
+                    if (!key_lookup.emplace(key).second) {
+                        throw std::ios_base::failure("Duplicate Key, sequence is already provided");
+                    } else if (key.size() != 1) {
+                        throw std::ios_base::failure("Sequence key is more than one byte type");
+                    }
+                    uint32_t v;
+                    UnserializeFromVector(s, v);
+                    sequence = v;
+                    break;
+                }
+                case PSBT_IN_REQUIRED_TIME_LOCKTIME:
+                {
+                    if (!key_lookup.emplace(key).second) {
+                        throw std::ios_base::failure("Duplicate Key, required time based locktime is already provided");
+                    } else if (key.size() != 1) {
+                        throw std::ios_base::failure("Required time based locktime is more than one byte type");
+                    }
+                    uint32_t v;
+                    UnserializeFromVector(s, v);
+                    time_locktime = v;
+                    break;
+                }
+                case PSBT_IN_REQUIRED_HEIGHT_LOCKTIME:
+                {
+                    if (!key_lookup.emplace(key).second) {
+                        throw std::ios_base::failure("Duplicate Key, required height based locktime is already provided");
+                    } else if (key.size() != 1) {
+                        throw std::ios_base::failure("Required height based locktime is more than one byte type");
+                    }
+                    uint32_t v;
+                    UnserializeFromVector(s, v);
+                    height_locktime = v;
+                    break;
+                }
                 case PSBT_IN_TAP_KEY_SIG:
                 {
                     if (!key_lookup.emplace(key).second) {
@@ -720,6 +808,8 @@ struct PSBTOutput
     CScript redeem_script;
     CScript witness_script;
     std::map<CPubKey, KeyOriginInfo> hd_keypaths;
+    std::optional<CAmount> amount;
+    std::optional<CScript> script;
     XOnlyPubKey m_tap_internal_key;
     TaprootBuilder m_tap_tree;
     std::map<XOnlyPubKey, std::pair<std::set<uint256>, KeyOriginInfo>> m_tap_bip32_paths;
@@ -749,6 +839,16 @@ struct PSBTOutput
         // Write any hd keypaths
         SerializeHDKeypaths(s, hd_keypaths, CompactSizeWriter(PSBT_OUT_BIP32_DERIVATION));
 
+        // Write amount and spk
+        if (amount != std::nullopt) {
+            SerializeToVector(s, CompactSizeWriter(PSBT_OUT_AMOUNT));
+            SerializeToVector(s, *amount);
+        }
+        if (script.has_value()) {
+            SerializeToVector(s, CompactSizeWriter(PSBT_OUT_SCRIPT));
+            s << *script;
+        }
+
         // Write proprietary things
         for (const auto& entry : m_proprietary) {
             s << entry.key;
@@ -849,6 +949,30 @@ struct PSBTOutput
                     DeserializeHDKeypaths(s, key, hd_keypaths);
                     break;
                 }
+                case PSBT_OUT_AMOUNT:
+                {
+                    if (!key_lookup.emplace(key).second) {
+                        throw std::ios_base::failure("Duplicate Key, output amount is already provided");
+                    } else if (key.size() != 1) {
+                        throw std::ios_base::failure("Output amount key is more than one byte type");
+                    }
+                    CAmount v;
+                    UnserializeFromVector(s, v);
+                    amount = v;
+                    break;
+                }
+                case PSBT_OUT_SCRIPT:
+                {
+                    if (!key_lookup.emplace(key).second) {
+                        throw std::ios_base::failure("Duplicate Key, output script is already provided");
+                    } else if (key.size() != 1) {
+                        throw std::ios_base::failure("Output script key is more than one byte type");
+                    }
+                    CScript v;
+                    s >> v;
+                    script = v;
+                    break;
+                }
                 case PSBT_OUT_TAP_INTERNAL_KEY:
                 {
                     if (!key_lookup.emplace(key).second) {
@@ -944,6 +1068,9 @@ struct PartiallySignedTransaction
     // We use a vector of CExtPubKey in the event that there happens to be the same KeyOriginInfos for different CExtPubKeys
     // Note that this map swaps the key and values from the serialization
     std::map<KeyOriginInfo, std::set<CExtPubKey>> m_xpubs;
+    std::optional<int32_t> tx_version;
+    std::optional<uint32_t> fallback_locktime;
+    std::optional<std::bitset<8>> m_tx_modifiable;
     std::vector<PSBTInput> inputs;
     std::vector<PSBTOutput> outputs;
     std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;
@@ -994,6 +1121,26 @@ struct PartiallySignedTransaction
             }
         }
 
+        // Write PSBTv2 tx version, locktime, counts, etc.
+        if (tx_version != std::nullopt) {
+            SerializeToVector(s, CompactSizeWriter(PSBT_GLOBAL_TX_VERSION));
+            SerializeToVector(s, *tx_version);
+        }
+        if (fallback_locktime != std::nullopt) {
+            SerializeToVector(s, CompactSizeWriter(PSBT_GLOBAL_FALLBACK_LOCKTIME));
+            SerializeToVector(s, *fallback_locktime);
+        }
+        if (m_version != std::nullopt && *m_version >= 2) {
+            SerializeToVector(s, CompactSizeWriter(PSBT_GLOBAL_INPUT_COUNT));
+            SerializeToVector(s, CompactSizeWriter(inputs.size()));
+            SerializeToVector(s, CompactSizeWriter(PSBT_GLOBAL_OUTPUT_COUNT));
+            SerializeToVector(s, CompactSizeWriter(outputs.size()));
+        }
+        if (m_tx_modifiable != std::nullopt) {
+            SerializeToVector(s, CompactSizeWriter(PSBT_GLOBAL_TX_MODIFIABLE));
+            SerializeToVector(s, static_cast<uint8_t>(m_tx_modifiable->to_ulong()));
+        }
+
         // PSBT version
         if (GetVersion() > 0) {
             SerializeToVector(s, CompactSizeWriter(PSBT_GLOBAL_VERSION));
@@ -1043,6 +1190,10 @@ struct PartiallySignedTransaction
 
         // Read global data
         bool found_sep = false;
+        uint64_t input_count = 0;
+        uint64_t output_count = 0;
+        bool found_input_count = false;
+        bool found_output_count = false;
         while(!s.empty()) {
             // Read
             std::vector<unsigned char> key;
@@ -1079,6 +1230,69 @@ struct PartiallySignedTransaction
                             throw std::ios_base::failure("Unsigned tx does not have empty scriptSigs and scriptWitnesses.");
                         }
                     }
+                    // Set the input and output counts
+                    input_count = tx->vin.size();
+                    output_count = tx->vout.size();
+                    break;
+                }
+                case PSBT_GLOBAL_TX_VERSION:
+                {
+                    if (!key_lookup.emplace(key).second) {
+                        throw std::ios_base::failure("Duplicate Key, global transaction version is already provided");
+                    } else if (key.size() != 1) {
+                        throw std::ios_base::failure("Global transaction version key is more than one byte type");
+                    }
+                    uint32_t v;
+                    UnserializeFromVector(s, v);
+                    tx_version = v;
+                    break;
+                }
+                case PSBT_GLOBAL_FALLBACK_LOCKTIME:
+                {
+                    if (!key_lookup.emplace(key).second) {
+                        throw std::ios_base::failure("Duplicate Key, global fallback locktime is already provided");
+                    } else if (key.size() != 1) {
+                        throw std::ios_base::failure("Global fallback locktime key is more than one byte type");
+                    }
+                    uint32_t v;
+                    UnserializeFromVector(s, v);
+                    fallback_locktime = v;
+                    break;
+                }
+                case PSBT_GLOBAL_INPUT_COUNT:
+                {
+                    if (!key_lookup.emplace(key).second) {
+                        throw std::ios_base::failure("Duplicate Key, global input count is already provided");
+                    } else if (key.size() != 1) {
+                        throw std::ios_base::failure("Global input count key is more than one byte type");
+                    }
+                    CompactSizeReader reader(input_count);
+                    UnserializeFromVector(s, reader);
+                    found_input_count = true;
+                    break;
+                }
+                case PSBT_GLOBAL_OUTPUT_COUNT:
+                {
+                    if (!key_lookup.emplace(key).second) {
+                        throw std::ios_base::failure("Duplicate Key, global output count is already provided");
+                    } else if (key.size() != 1) {
+                        throw std::ios_base::failure("Global output count key is more than one byte type");
+                    }
+                    CompactSizeReader reader(output_count);
+                    UnserializeFromVector(s, reader);
+                    found_output_count = true;
+                    break;
+                }
+                case PSBT_GLOBAL_TX_MODIFIABLE:
+                {
+                    if (!key_lookup.emplace(key).second) {
+                        throw std::ios_base::failure("Duplicate Key, tx modifiable flags is already provided");
+                    } else if (key.size() != 1) {
+                        throw std::ios_base::failure("Global tx modifiable flags key is more than one byte type");
+                    }
+                    uint8_t tx_mod;
+                    UnserializeFromVector(s, tx_mod);
+                    m_tx_modifiable.emplace(tx_mod);
                     break;
                 }
                 case PSBT_GLOBAL_XPUB:
@@ -1164,7 +1378,7 @@ struct PartiallySignedTransaction
 
         // Read input data
         unsigned int i = 0;
-        while (!s.empty() && i < tx->vin.size()) {
+        while (!s.empty() && i < input_count) {
             PSBTInput input;
             s >> input;
             inputs.push_back(input);
@@ -1176,20 +1390,20 @@ struct PartiallySignedTransaction
             ++i;
         }
         // Make sure that the number of inputs matches the number of inputs in the transaction
-        if (inputs.size() != tx->vin.size()) {
+        if (inputs.size() != input_count) {
             throw std::ios_base::failure("Inputs provided does not match the number of inputs in transaction.");
         }
 
         // Read output data
         i = 0;
-        while (!s.empty() && i < tx->vout.size()) {
+        while (!s.empty() && i < output_count) {
             PSBTOutput output;
             s >> output;
             outputs.push_back(output);
             ++i;
         }
         // Make sure that the number of outputs matches the number of outputs in the transaction
-        if (outputs.size() != tx->vout.size()) {
+        if (outputs.size() != output_count) {
             throw std::ios_base::failure("Outputs provided does not match the number of outputs in transaction.");
         }
     }
diff --git a/src/serialize.h b/src/serialize.h
index a1cce78451..45748b99ab 100644
--- a/src/serialize.h
+++ b/src/serialize.h
@@ -520,6 +520,19 @@ struct CompactSizeFormatter
     }
 };
 
+class CompactSizeReader
+{
+protected:
+    uint64_t& n;
+public:
+    explicit CompactSizeReader(uint64_t& n_in) : n(n_in) {}
+
+    template<typename Stream>
+    void Unserialize(Stream &s) const {
+        n = ReadCompactSize<Stream>(s);
+    }
+};
+
 class CompactSizeWriter
 {
 protected:
-- 
2.36.1


From ffdb4b86ed68fda50a9ce8f56b4357d5a5be232c Mon Sep 17 00:00:00 2001
From: Andrew Chow <achow101-github@achow101.com>
Date: Mon, 4 Jan 2021 17:23:10 -0500
Subject: [PATCH 21/48] Have PSBTInput and PSBTOutput know the PSBT's version

---
 src/psbt.cpp                  |  4 ++--
 src/psbt.h                    | 14 ++++++++++----
 src/rpc/rawtransaction.cpp    |  8 ++++----
 src/test/fuzz/deserialize.cpp |  4 ++--
 4 files changed, 18 insertions(+), 12 deletions(-)

diff --git a/src/psbt.cpp b/src/psbt.cpp
index d038fced08..6ffe86acce 100644
--- a/src/psbt.cpp
+++ b/src/psbt.cpp
@@ -10,8 +10,8 @@
 
 PartiallySignedTransaction::PartiallySignedTransaction(const CMutableTransaction& tx) : tx(tx)
 {
-    inputs.resize(tx.vin.size());
-    outputs.resize(tx.vout.size());
+    inputs.resize(tx.vin.size(), PSBTInput(GetVersion()));
+    outputs.resize(tx.vout.size(), PSBTOutput(GetVersion()));
 }
 
 bool PartiallySignedTransaction::IsNull() const
diff --git a/src/psbt.h b/src/psbt.h
index 6eff336806..b9d79fb501 100644
--- a/src/psbt.h
+++ b/src/psbt.h
@@ -236,11 +236,13 @@ struct PSBTInput
     std::set<PSBTProprietary> m_proprietary;
     std::optional<int> sighash_type;
 
+    uint32_t m_psbt_version;
+
     bool IsNull() const;
     void FillSignatureData(SignatureData& sigdata) const;
     void FromSignatureData(const SignatureData& sigdata);
     void Merge(const PSBTInput& input);
-    PSBTInput() {}
+    PSBTInput(uint32_t version) : m_psbt_version(version) {}
 
     template <typename Stream>
     inline void Serialize(Stream& s) const {
@@ -816,11 +818,13 @@ struct PSBTOutput
     std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;
     std::set<PSBTProprietary> m_proprietary;
 
+    uint32_t m_psbt_version;
+
     bool IsNull() const;
     void FillSignatureData(SignatureData& sigdata) const;
     void FromSignatureData(const SignatureData& sigdata);
     void Merge(const PSBTOutput& output);
-    PSBTOutput() {}
+    PSBTOutput(uint32_t version) : m_psbt_version(version) {}
 
     template <typename Stream>
     inline void Serialize(Stream& s) const {
@@ -1376,10 +1380,12 @@ struct PartiallySignedTransaction
             throw std::ios_base::failure("No unsigned transcation was provided");
         }
 
+        uint32_t psbt_ver = GetVersion();
+
         // Read input data
         unsigned int i = 0;
         while (!s.empty() && i < input_count) {
-            PSBTInput input;
+            PSBTInput input(psbt_ver);
             s >> input;
             inputs.push_back(input);
 
@@ -1397,7 +1403,7 @@ struct PartiallySignedTransaction
         // Read output data
         i = 0;
         while (!s.empty() && i < output_count) {
-            PSBTOutput output;
+            PSBTOutput output(psbt_ver);
             s >> output;
             outputs.push_back(output);
             ++i;
diff --git a/src/rpc/rawtransaction.cpp b/src/rpc/rawtransaction.cpp
index 5a5743325b..16ad18a031 100644
--- a/src/rpc/rawtransaction.cpp
+++ b/src/rpc/rawtransaction.cpp
@@ -1455,10 +1455,10 @@ static RPCHelpMan createpsbt()
     PartiallySignedTransaction psbtx;
     psbtx.tx = rawTx;
     for (unsigned int i = 0; i < rawTx.vin.size(); ++i) {
-        psbtx.inputs.push_back(PSBTInput());
+        psbtx.inputs.push_back(PSBTInput(0));
     }
     for (unsigned int i = 0; i < rawTx.vout.size(); ++i) {
-        psbtx.outputs.push_back(PSBTOutput());
+        psbtx.outputs.push_back(PSBTOutput(0));
     }
 
     // Serialize the PSBT
@@ -1524,10 +1524,10 @@ static RPCHelpMan converttopsbt()
     PartiallySignedTransaction psbtx;
     psbtx.tx = tx;
     for (unsigned int i = 0; i < tx.vin.size(); ++i) {
-        psbtx.inputs.push_back(PSBTInput());
+        psbtx.inputs.push_back(PSBTInput(0));
     }
     for (unsigned int i = 0; i < tx.vout.size(); ++i) {
-        psbtx.outputs.push_back(PSBTOutput());
+        psbtx.outputs.push_back(PSBTOutput(0));
     }
 
     // Serialize the PSBT
diff --git a/src/test/fuzz/deserialize.cpp b/src/test/fuzz/deserialize.cpp
index 0a7d0c55bd..a71b054ffd 100644
--- a/src/test/fuzz/deserialize.cpp
+++ b/src/test/fuzz/deserialize.cpp
@@ -179,11 +179,11 @@ FUZZ_TARGET_DESERIALIZE(prefilled_transaction_deserialize, {
     DeserializeFromFuzzingInput(buffer, prefilled_transaction);
 })
 FUZZ_TARGET_DESERIALIZE(psbt_input_deserialize, {
-    PSBTInput psbt_input;
+    PSBTInput psbt_input(0);
     DeserializeFromFuzzingInput(buffer, psbt_input);
 })
 FUZZ_TARGET_DESERIALIZE(psbt_output_deserialize, {
-    PSBTOutput psbt_output;
+    PSBTOutput psbt_output(0);
     DeserializeFromFuzzingInput(buffer, psbt_output);
 })
 FUZZ_TARGET_DESERIALIZE(block_deserialize, {
-- 
2.36.1


From abdd28f586c6aac889839551a2230c5dbea5329b Mon Sep 17 00:00:00 2001
From: Andrew Chow <achow101-github@achow101.com>
Date: Mon, 4 Jan 2021 17:23:56 -0500
Subject: [PATCH 22/48] Enforce PSBT version constraints

With PSBTv2, some fields are not allowed in PSBTv2, and some are
required. Enforce those.
---
 src/psbt.h | 178 ++++++++++++++++++++++++++++++++++++++---------------
 1 file changed, 127 insertions(+), 51 deletions(-)

diff --git a/src/psbt.h b/src/psbt.h
index b9d79fb501..4afca03a48 100644
--- a/src/psbt.h
+++ b/src/psbt.h
@@ -368,26 +368,29 @@ struct PSBTInput
             SerializeToVector(s, final_script_witness.stack);
         }
 
-        // Write prev txid, vout, sequence, and lock times
-        if (!prev_txid.IsNull()) {
-            SerializeToVector(s, CompactSizeWriter(PSBT_IN_PREVIOUS_TXID));
-            SerializeToVector(s, prev_txid);
-        }
-        if (prev_out != std::nullopt) {
-            SerializeToVector(s, CompactSizeWriter(PSBT_IN_OUTPUT_INDEX));
-            SerializeToVector(s, *prev_out);
-        }
-        if (sequence != std::nullopt) {
-            SerializeToVector(s, CompactSizeWriter(PSBT_IN_SEQUENCE));
-            SerializeToVector(s, *sequence);
-        }
-        if (time_locktime != std::nullopt) {
-            SerializeToVector(s, CompactSizeWriter(PSBT_IN_REQUIRED_TIME_LOCKTIME));
-            SerializeToVector(s, *time_locktime);
-        }
-        if (height_locktime != std::nullopt) {
-            SerializeToVector(s, CompactSizeWriter(PSBT_IN_REQUIRED_HEIGHT_LOCKTIME));
-            SerializeToVector(s, *height_locktime);
+        // Write PSBTv2 fields
+        if (m_psbt_version >= 2) {
+            // Write prev txid, vout, sequence, and lock times
+            if (!prev_txid.IsNull()) {
+                SerializeToVector(s, CompactSizeWriter(PSBT_IN_PREVIOUS_TXID));
+                SerializeToVector(s, prev_txid);
+            }
+            if (prev_out != std::nullopt) {
+                SerializeToVector(s, CompactSizeWriter(PSBT_IN_OUTPUT_INDEX));
+                SerializeToVector(s, *prev_out);
+            }
+            if (sequence != std::nullopt) {
+                SerializeToVector(s, CompactSizeWriter(PSBT_IN_SEQUENCE));
+                SerializeToVector(s, *sequence);
+            }
+            if (time_locktime != std::nullopt) {
+                SerializeToVector(s, CompactSizeWriter(PSBT_IN_REQUIRED_TIME_LOCKTIME));
+                SerializeToVector(s, *time_locktime);
+            }
+            if (height_locktime != std::nullopt) {
+                SerializeToVector(s, CompactSizeWriter(PSBT_IN_REQUIRED_HEIGHT_LOCKTIME));
+                SerializeToVector(s, *height_locktime);
+            }
         }
 
         // Write proprietary things
@@ -619,6 +622,8 @@ struct PSBTInput
                         throw std::ios_base::failure("Duplicate Key, previous txid is already provided");
                     } else if (key.size() != 1) {
                         throw std::ios_base::failure("Previous txid key is more than one byte type");
+                    } else if (m_psbt_version == 0) {
+                        throw std::ios_base::failure("Previous txid is only allowed in PSBTv2");
                     }
                     UnserializeFromVector(s, prev_txid);
                     break;
@@ -629,6 +634,8 @@ struct PSBTInput
                         throw std::ios_base::failure("Duplicate Key, previous output's index is already provided");
                     } else if (key.size() != 1) {
                         throw std::ios_base::failure("Previous output's index is more than one byte type");
+                    } else if (m_psbt_version == 0) {
+                        throw std::ios_base::failure("Previous output's index is only allowed in PSBTv2");
                     }
                     uint32_t v;
                     UnserializeFromVector(s, v);
@@ -641,6 +648,8 @@ struct PSBTInput
                         throw std::ios_base::failure("Duplicate Key, sequence is already provided");
                     } else if (key.size() != 1) {
                         throw std::ios_base::failure("Sequence key is more than one byte type");
+                    } else if (m_psbt_version == 0) {
+                        throw std::ios_base::failure("Sequence is only allowed in PSBTv2");
                     }
                     uint32_t v;
                     UnserializeFromVector(s, v);
@@ -653,6 +662,8 @@ struct PSBTInput
                         throw std::ios_base::failure("Duplicate Key, required time based locktime is already provided");
                     } else if (key.size() != 1) {
                         throw std::ios_base::failure("Required time based locktime is more than one byte type");
+                    } else if (m_psbt_version == 0) {
+                        throw std::ios_base::failure("Required time based locktime is only allowed in PSBTv2");
                     }
                     uint32_t v;
                     UnserializeFromVector(s, v);
@@ -665,6 +676,8 @@ struct PSBTInput
                         throw std::ios_base::failure("Duplicate Key, required height based locktime is already provided");
                     } else if (key.size() != 1) {
                         throw std::ios_base::failure("Required height based locktime is more than one byte type");
+                    } else if (m_psbt_version == 0) {
+                        throw std::ios_base::failure("Required height based locktime is only allowed in PSBTv2");
                     }
                     uint32_t v;
                     UnserializeFromVector(s, v);
@@ -796,6 +809,16 @@ struct PSBTInput
         if (!found_sep) {
             throw std::ios_base::failure("Separator is missing at the end of an input map");
         }
+
+        // Make sure required PSBTv2 fields are present
+        if (m_psbt_version >= 2) {
+            if (prev_txid.IsNull()) {
+                throw std::ios_base::failure("Previous TXID is required in PSBTv2");
+            }
+            if (prev_out == std::nullopt) {
+                throw std::ios_base::failure("Previous output's index is required in PSBTv2");
+            }
+        }
     }
 
     template <typename Stream>
@@ -843,14 +866,16 @@ struct PSBTOutput
         // Write any hd keypaths
         SerializeHDKeypaths(s, hd_keypaths, CompactSizeWriter(PSBT_OUT_BIP32_DERIVATION));
 
-        // Write amount and spk
-        if (amount != std::nullopt) {
-            SerializeToVector(s, CompactSizeWriter(PSBT_OUT_AMOUNT));
-            SerializeToVector(s, *amount);
-        }
-        if (script.has_value()) {
-            SerializeToVector(s, CompactSizeWriter(PSBT_OUT_SCRIPT));
-            s << *script;
+        if (m_psbt_version >= 2) {
+            // Write amount and spk
+            if (amount != std::nullopt) {
+                SerializeToVector(s, CompactSizeWriter(PSBT_OUT_AMOUNT));
+                SerializeToVector(s, *amount);
+            }
+            if (script.has_value()) {
+                SerializeToVector(s, CompactSizeWriter(PSBT_OUT_SCRIPT));
+                s << *script;
+            }
         }
 
         // Write proprietary things
@@ -1057,6 +1082,16 @@ struct PSBTOutput
         if (!found_sep) {
             throw std::ios_base::failure("Separator is missing at the end of an output map");
         }
+
+        // Make sure required PSBTv2 fields are present
+        if (m_psbt_version >= 2) {
+            if (amount == std::nullopt) {
+                throw std::ios_base::failure("Output amount is required in PSBTv2");
+            }
+            if (!script.has_value()) {
+                throw std::ios_base::failure("Output script is required in PSBTv2");
+            }
+        }
     }
 
     template <typename Stream>
@@ -1106,12 +1141,14 @@ struct PartiallySignedTransaction
         // magic bytes
         s << PSBT_MAGIC_BYTES;
 
-        // unsigned tx flag
-        SerializeToVector(s, CompactSizeWriter(PSBT_GLOBAL_UNSIGNED_TX));
+        if (GetVersion() == 0) {
+            // unsigned tx flag
+            SerializeToVector(s, CompactSizeWriter(PSBT_GLOBAL_UNSIGNED_TX));
 
-        // Write serialized tx to a stream
-        OverrideStream<Stream> os(&s, s.GetType(), s.GetVersion() | SERIALIZE_TRANSACTION_NO_WITNESS);
-        SerializeToVector(os, *tx);
+            // Write serialized tx to a stream
+            OverrideStream<Stream> os(&s, s.GetType(), s.GetVersion() | SERIALIZE_TRANSACTION_NO_WITNESS);
+            SerializeToVector(os, *tx);
+        }
 
         // Write xpubs
         for (const auto& xpub_pair : m_xpubs) {
@@ -1125,24 +1162,24 @@ struct PartiallySignedTransaction
             }
         }
 
-        // Write PSBTv2 tx version, locktime, counts, etc.
-        if (tx_version != std::nullopt) {
+        if (GetVersion() >= 2) {
+            // Write PSBTv2 tx version, locktime, counts, etc.
             SerializeToVector(s, CompactSizeWriter(PSBT_GLOBAL_TX_VERSION));
             SerializeToVector(s, *tx_version);
-        }
-        if (fallback_locktime != std::nullopt) {
-            SerializeToVector(s, CompactSizeWriter(PSBT_GLOBAL_FALLBACK_LOCKTIME));
-            SerializeToVector(s, *fallback_locktime);
-        }
-        if (m_version != std::nullopt && *m_version >= 2) {
+            if (fallback_locktime != std::nullopt) {
+                SerializeToVector(s, CompactSizeWriter(PSBT_GLOBAL_FALLBACK_LOCKTIME));
+                SerializeToVector(s, *fallback_locktime);
+            }
+
             SerializeToVector(s, CompactSizeWriter(PSBT_GLOBAL_INPUT_COUNT));
             SerializeToVector(s, CompactSizeWriter(inputs.size()));
             SerializeToVector(s, CompactSizeWriter(PSBT_GLOBAL_OUTPUT_COUNT));
             SerializeToVector(s, CompactSizeWriter(outputs.size()));
-        }
-        if (m_tx_modifiable != std::nullopt) {
-            SerializeToVector(s, CompactSizeWriter(PSBT_GLOBAL_TX_MODIFIABLE));
-            SerializeToVector(s, static_cast<uint8_t>(m_tx_modifiable->to_ulong()));
+
+            if (m_tx_modifiable != std::nullopt) {
+                SerializeToVector(s, CompactSizeWriter(PSBT_GLOBAL_TX_MODIFIABLE));
+                SerializeToVector(s, static_cast<uint8_t>(m_tx_modifiable->to_ulong()));
+            }
         }
 
         // PSBT version
@@ -1375,13 +1412,52 @@ struct PartiallySignedTransaction
             throw std::ios_base::failure("Separator is missing at the end of the global map");
         }
 
-        // Make sure that we got an unsigned tx
-        if (!tx) {
-            throw std::ios_base::failure("No unsigned transcation was provided");
-        }
-
         uint32_t psbt_ver = GetVersion();
 
+        // Check PSBT version constraints
+        if (psbt_ver == 0) {
+            // Make sure that we got an unsigned tx for PSBTv0
+            if (!tx) {
+                throw std::ios_base::failure("No unsigned transcation was provided");
+            }
+            // Make sure no PSBTv2 fields are present
+            if (tx_version != std::nullopt) {
+                throw std::ios_base::failure("PSBT_GLOBAL_TX_VERSION is not allowed in PSBTv0");
+            }
+            if (fallback_locktime != std::nullopt) {
+                throw std::ios_base::failure("PSBT_GLOBAL_FALLBACK_LOCKTIME is not allowed in PSBTv0");
+            }
+            if (found_input_count) {
+                throw std::ios_base::failure("PSBT_GLOBAL_INPUT_COUNT is not allowed in PSBTv0");
+            }
+            if (found_output_count) {
+                throw std::ios_base::failure("PSBT_GLOBAL_OUTPUT_COUNT is not allowed in PSBTv0");
+            }
+            if (m_tx_modifiable != std::nullopt) {
+                throw std::ios_base::failure("PSBT_GLOBAL_TX_MODIFIABLE is not allowed in PSBTv0");
+            }
+        }
+        // Disallow v1
+        if (psbt_ver == 1) {
+            throw std::ios_base::failure("There is no PSBT version 1");
+        }
+        if (psbt_ver >= 2) {
+            // Tx version, input, and output counts are required
+            if (tx_version == std::nullopt) {
+                throw std::ios_base::failure("PSBT_GLOBAL_TX_VERSION is required in PSBTv2");
+            }
+            if (!found_input_count) {
+                throw std::ios_base::failure("PSBT_GLOBAL_INPUT_COUNT is required in PSBTv2");
+            }
+            if (!found_output_count) {
+                throw std::ios_base::failure("PSBT_GLOBAL_OUTPUT_COUNT is required in PSBTv2");
+            }
+            // Unsigned tx is disallowed
+            if (tx) {
+                throw std::ios_base::failure("PSBT_GLOBAL_UNSIGNED_TX is not allowed in PSBTv2");
+            }
+        }
+
         // Read input data
         unsigned int i = 0;
         while (!s.empty() && i < input_count) {
@@ -1390,7 +1466,7 @@ struct PartiallySignedTransaction
             inputs.push_back(input);
 
             // Make sure the non-witness utxo matches the outpoint
-            if (input.non_witness_utxo && input.non_witness_utxo->GetHash() != tx->vin[i].prevout.hash) {
+            if (input.non_witness_utxo && ((tx != std::nullopt && input.non_witness_utxo->GetHash() != tx->vin[i].prevout.hash) || (!input.prev_txid.IsNull() && input.non_witness_utxo->GetHash() != input.prev_txid))) {
                 throw std::ios_base::failure("Non-witness UTXO does not match outpoint hash");
             }
             ++i;
-- 
2.36.1


From 7190ff353a66ec1b2fd47d93fe82a15aa13421c8 Mon Sep 17 00:00:00 2001
From: Andrew Chow <achow101-github@achow101.com>
Date: Mon, 11 Jan 2021 18:34:38 -0500
Subject: [PATCH 23/48] Add PSBT::CacheUnsignedTxPieces

Fetches the PSBTv2 fields from PSBTv0's global unsigned tx. This allows
us to pretend everything internally is a PSBTv2 and makes things easier
to work with.
---
 src/psbt.cpp | 33 +++++++++++++++++++++++++++++++++
 src/psbt.h   |  2 ++
 2 files changed, 35 insertions(+)

diff --git a/src/psbt.cpp b/src/psbt.cpp
index 6ffe86acce..df6a5eb647 100644
--- a/src/psbt.cpp
+++ b/src/psbt.cpp
@@ -483,3 +483,36 @@ uint32_t PartiallySignedTransaction::GetVersion() const
     }
     return 0;
 }
+
+void PartiallySignedTransaction::SetupFromTx(const CMutableTransaction& tx)
+{
+    tx_version = tx.nVersion;
+    fallback_locktime = tx.nLockTime;
+
+    uint32_t i;
+    for (i = 0; i < tx.vin.size(); ++i) {
+        PSBTInput& input = inputs.at(i);
+        const CTxIn& txin = tx.vin.at(i);
+
+        input.prev_txid = txin.prevout.hash;
+        input.prev_out = txin.prevout.n;
+        input.sequence = txin.nSequence;
+    }
+
+    for (i = 0; i < tx.vout.size(); ++i) {
+        PSBTOutput& output = outputs.at(i);
+        const CTxOut& txout = tx.vout.at(i);
+
+        output.amount = txout.nValue;
+        output.script = txout.scriptPubKey;
+    }
+}
+
+void PartiallySignedTransaction::CacheUnsignedTxPieces()
+{
+    // To make things easier, we split up the global unsigned transaction
+    // and use the PSBTv2 fields for PSBTv0.
+    if (tx != std::nullopt) {
+        SetupFromTx(*tx);
+    }
+}
diff --git a/src/psbt.h b/src/psbt.h
index 4afca03a48..ec10586aa4 100644
--- a/src/psbt.h
+++ b/src/psbt.h
@@ -1124,6 +1124,8 @@ struct PartiallySignedTransaction
     [[nodiscard]] bool Merge(const PartiallySignedTransaction& psbt);
     bool AddInput(const CTxIn& txin, PSBTInput& psbtin);
     bool AddOutput(const CTxOut& txout, const PSBTOutput& psbtout);
+    void SetupFromTx(const CMutableTransaction& tx);
+    void CacheUnsignedTxPieces();
     PartiallySignedTransaction() {}
     explicit PartiallySignedTransaction(const CMutableTransaction& tx);
     /**
-- 
2.36.1


From 433f638a28349272aff3b76152939cabcf930114 Mon Sep 17 00:00:00 2001
From: Andrew Chow <achow101-github@achow101.com>
Date: Mon, 11 Jan 2021 18:35:32 -0500
Subject: [PATCH 24/48] Call CacheUnsignedTxPieces in PSBT constructor

---
 src/psbt.cpp | 1 +
 1 file changed, 1 insertion(+)

diff --git a/src/psbt.cpp b/src/psbt.cpp
index df6a5eb647..57a66b9c43 100644
--- a/src/psbt.cpp
+++ b/src/psbt.cpp
@@ -12,6 +12,7 @@ PartiallySignedTransaction::PartiallySignedTransaction(const CMutableTransaction
 {
     inputs.resize(tx.vin.size(), PSBTInput(GetVersion()));
     outputs.resize(tx.vout.size(), PSBTOutput(GetVersion()));
+    CacheUnsignedTxPieces();
 }
 
 bool PartiallySignedTransaction::IsNull() const
-- 
2.36.1


From 20e6feb1a6ccb42fc569ac43d677dae97f3cb084 Mon Sep 17 00:00:00 2001
From: Andrew Chow <achow101-github@achow101.com>
Date: Mon, 11 Jan 2021 15:27:38 -0500
Subject: [PATCH 25/48] Convert PSBTv0 unsigned tx to PSBTv2 fields

This is just a convenience and doesn't effect serialization.
---
 src/psbt.h | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/src/psbt.h b/src/psbt.h
index ec10586aa4..4fe43557e2 100644
--- a/src/psbt.h
+++ b/src/psbt.h
@@ -1490,6 +1490,8 @@ struct PartiallySignedTransaction
         if (outputs.size() != output_count) {
             throw std::ios_base::failure("Outputs provided does not match the number of outputs in transaction.");
         }
+
+        CacheUnsignedTxPieces();
     }
 
     template <typename Stream>
-- 
2.36.1


From 648900098177b746afd55cb40b1b0e745702c1a0 Mon Sep 17 00:00:00 2001
From: Andrew Chow <achow101-github@achow101.com>
Date: Mon, 11 Jan 2021 15:50:27 -0500
Subject: [PATCH 26/48] Replace PSBT::GetInputUTXO with PSBTInput::GetUTXO

Now that PSBTInput's track their own prevouts, there's no need for a
PSBT global function to fetch input specific data.
---
 src/node/psbt.cpp      |  4 ++--
 src/psbt.cpp           | 22 ++++++++++------------
 src/psbt.h             | 15 +++++++--------
 src/test/fuzz/psbt.cpp |  2 +-
 4 files changed, 20 insertions(+), 23 deletions(-)

diff --git a/src/node/psbt.cpp b/src/node/psbt.cpp
index 5a932f435d..eca2da5fd4 100644
--- a/src/node/psbt.cpp
+++ b/src/node/psbt.cpp
@@ -35,7 +35,7 @@ PSBTAnalysis AnalyzePSBT(PartiallySignedTransaction psbtx)
 
         // Check for a UTXO
         CTxOut utxo;
-        if (psbtx.GetInputUTXO(utxo, i)) {
+        if (input.GetUTXO(utxo)) {
             if (!MoneyRange(utxo.nValue) || !MoneyRange(in_amt + utxo.nValue)) {
                 result.SetInvalid(strprintf("PSBT is not valid. Input %u has invalid value", i));
                 return result;
@@ -124,7 +124,7 @@ PSBTAnalysis AnalyzePSBT(PartiallySignedTransaction psbtx)
             PSBTInput& input = psbtx.inputs[i];
             Coin newcoin;
 
-            if (!SignPSBTInput(DUMMY_SIGNING_PROVIDER, psbtx, i, nullptr, 1) || !psbtx.GetInputUTXO(newcoin.out, i)) {
+            if (!SignPSBTInput(DUMMY_SIGNING_PROVIDER, psbtx, i, nullptr, 1) || !input.GetUTXO(newcoin.out)) {
                 success = false;
                 break;
             } else {
diff --git a/src/psbt.cpp b/src/psbt.cpp
index 57a66b9c43..583d3de976 100644
--- a/src/psbt.cpp
+++ b/src/psbt.cpp
@@ -65,20 +65,18 @@ bool PartiallySignedTransaction::AddOutput(const CTxOut& txout, const PSBTOutput
     return true;
 }
 
-bool PartiallySignedTransaction::GetInputUTXO(CTxOut& utxo, int input_index) const
+bool PSBTInput::GetUTXO(CTxOut& utxo) const
 {
-    const PSBTInput& input = inputs[input_index];
-    uint32_t prevout_index = tx->vin[input_index].prevout.n;
-    if (input.non_witness_utxo) {
-        if (prevout_index >= input.non_witness_utxo->vout.size()) {
+    if (non_witness_utxo) {
+        if (prev_out >= non_witness_utxo->vout.size()) {
             return false;
         }
-        if (input.non_witness_utxo->GetHash() != tx->vin[input_index].prevout.hash) {
+        if (non_witness_utxo->GetHash() != prev_txid) {
             return false;
         }
-        utxo = input.non_witness_utxo->vout[prevout_index];
-    } else if (!input.witness_utxo.IsNull()) {
-        utxo = input.witness_utxo;
+        utxo = non_witness_utxo->vout[*prev_out];
+    } else if (!witness_utxo.IsNull()) {
+        utxo = witness_utxo;
     } else {
         return false;
     }
@@ -309,9 +307,9 @@ PrecomputedTransactionData PrecomputePSBTData(const PartiallySignedTransaction&
 {
     const CMutableTransaction& tx = *psbt.tx;
     bool have_all_spent_outputs = true;
-    std::vector<CTxOut> utxos(tx.vin.size());
-    for (size_t idx = 0; idx < tx.vin.size(); ++idx) {
-        if (!psbt.GetInputUTXO(utxos[idx], idx)) have_all_spent_outputs = false;
+    std::vector<CTxOut> utxos;
+    for (const PSBTInput& input : psbt.inputs) {
+        if (!input.GetUTXO(utxos.emplace_back())) have_all_spent_outputs = false;
     }
     PrecomputedTransactionData txdata;
     if (have_all_spent_outputs) {
diff --git a/src/psbt.h b/src/psbt.h
index 4fe43557e2..47dc1ac36c 100644
--- a/src/psbt.h
+++ b/src/psbt.h
@@ -242,6 +242,13 @@ struct PSBTInput
     void FillSignatureData(SignatureData& sigdata) const;
     void FromSignatureData(const SignatureData& sigdata);
     void Merge(const PSBTInput& input);
+    /**
+     * Retrieves the UTXO for this input
+     *
+     * @param[out] utxo The UTXO of this input
+     * @return Whether the UTXO could be retrieved
+     */
+    bool GetUTXO(CTxOut& utxo) const;
     PSBTInput(uint32_t version) : m_psbt_version(version) {}
 
     template <typename Stream>
@@ -1128,14 +1135,6 @@ struct PartiallySignedTransaction
     void CacheUnsignedTxPieces();
     PartiallySignedTransaction() {}
     explicit PartiallySignedTransaction(const CMutableTransaction& tx);
-    /**
-     * Finds the UTXO for a given input index
-     *
-     * @param[out] utxo The UTXO of the input if found
-     * @param[in] input_index Index of the input to retrieve the UTXO of
-     * @return Whether the UTXO for the specified input was found
-     */
-    bool GetInputUTXO(CTxOut& utxo, int input_index) const;
 
     template <typename Stream>
     inline void Serialize(Stream& s) const {
diff --git a/src/test/fuzz/psbt.cpp b/src/test/fuzz/psbt.cpp
index baa64bba0f..e38b7e97b9 100644
--- a/src/test/fuzz/psbt.cpp
+++ b/src/test/fuzz/psbt.cpp
@@ -64,7 +64,7 @@ FUZZ_TARGET_INIT(psbt, initialize_psbt)
 
     for (size_t i = 0; i < psbt.tx->vin.size(); ++i) {
         CTxOut tx_out;
-        if (psbt.GetInputUTXO(tx_out, i)) {
+        if (psbt.inputs.at(i).GetUTXO(tx_out)) {
             (void)tx_out.IsNull();
             (void)tx_out.ToString();
         }
-- 
2.36.1


From ba87da62bba8be3b69b39a2f28d90674ffe2ae3c Mon Sep 17 00:00:00 2001
From: Andrew Chow <achow101-github@achow101.com>
Date: Mon, 11 Jan 2021 16:15:04 -0500
Subject: [PATCH 27/48] Add PSBT::ComputeLockTime()

Function to compute the lock time for the transaction
---
 src/psbt.cpp | 35 +++++++++++++++++++++++++++++++++++
 src/psbt.h   |  1 +
 2 files changed, 36 insertions(+)

diff --git a/src/psbt.cpp b/src/psbt.cpp
index 583d3de976..eed5c6dce6 100644
--- a/src/psbt.cpp
+++ b/src/psbt.cpp
@@ -45,6 +45,41 @@ bool PartiallySignedTransaction::Merge(const PartiallySignedTransaction& psbt)
     return true;
 }
 
+bool PartiallySignedTransaction::ComputeTimeLock(uint32_t& locktime) const
+{
+    std::optional<uint32_t> time_lock{0};
+    std::optional<uint32_t> height_lock{0};
+    for (const PSBTInput& input : inputs) {
+        if (input.time_locktime != std::nullopt && input.height_locktime == std::nullopt) {
+            height_lock.reset(); // Transaction can no longer have a height locktime
+            if (time_lock == std::nullopt) {
+                return false;
+            }
+        } else if (input.time_locktime == std::nullopt && input.height_locktime != std::nullopt) {
+            time_lock.reset(); // Transaction can no longer have a time locktime
+            if (height_lock == std::nullopt) {
+                return false;
+            }
+        }
+        if (input.time_locktime && time_lock != std::nullopt) {
+            time_lock = std::max(time_lock, input.time_locktime);
+        }
+        if (input.height_locktime && height_lock != std::nullopt) {
+            height_lock = std::max(height_lock, input.height_locktime);
+        }
+    }
+    if (height_lock != std::nullopt && *height_lock > 0) {
+        locktime = *height_lock;
+        return true;
+    }
+    if (time_lock != std::nullopt && *time_lock > 0) {
+        locktime = *time_lock;
+        return true;
+    }
+    locktime = fallback_locktime.value_or(0);
+    return true;
+}
+
 bool PartiallySignedTransaction::AddInput(const CTxIn& txin, PSBTInput& psbtin)
 {
     if (std::find(tx->vin.begin(), tx->vin.end(), txin) != tx->vin.end()) {
diff --git a/src/psbt.h b/src/psbt.h
index 47dc1ac36c..112b681363 100644
--- a/src/psbt.h
+++ b/src/psbt.h
@@ -1133,6 +1133,7 @@ struct PartiallySignedTransaction
     bool AddOutput(const CTxOut& txout, const PSBTOutput& psbtout);
     void SetupFromTx(const CMutableTransaction& tx);
     void CacheUnsignedTxPieces();
+    bool ComputeTimeLock(uint32_t& locktime) const;
     PartiallySignedTransaction() {}
     explicit PartiallySignedTransaction(const CMutableTransaction& tx);
 
-- 
2.36.1


From 2ef8c101f60831905acc3e97ab9ffc2655538544 Mon Sep 17 00:00:00 2001
From: Andrew Chow <achow101-github@achow101.com>
Date: Mon, 11 Jan 2021 16:21:42 -0500
Subject: [PATCH 28/48] Add PSBT::GetUnsignedTx

A helper function for getting the unsigned transaction regardless of
psbt version.
---
 src/psbt.cpp | 28 ++++++++++++++++++++++++++++
 src/psbt.h   |  1 +
 2 files changed, 29 insertions(+)

diff --git a/src/psbt.cpp b/src/psbt.cpp
index eed5c6dce6..823bc5ce8c 100644
--- a/src/psbt.cpp
+++ b/src/psbt.cpp
@@ -4,6 +4,7 @@
 
 #include <psbt.h>
 
+#include <primitives/transaction.h>
 #include <util/check.h>
 #include <util/strencodings.h>
 
@@ -80,6 +81,33 @@ bool PartiallySignedTransaction::ComputeTimeLock(uint32_t& locktime) const
     return true;
 }
 
+CMutableTransaction PartiallySignedTransaction::GetUnsignedTx() const
+{
+    if (tx != std::nullopt) {
+        return *tx;
+    }
+
+    CMutableTransaction mtx;
+    mtx.nVersion = *tx_version;
+    bool locktime_success = ComputeTimeLock(mtx.nLockTime);
+    assert(locktime_success);
+    uint32_t max_sequence = CTxIn::SEQUENCE_FINAL;
+    for (const PSBTInput& input : inputs) {
+        CTxIn txin;
+        txin.prevout.hash = input.prev_txid;
+        txin.prevout.n = *input.prev_out;
+        txin.nSequence = input.sequence.value_or(max_sequence);
+        mtx.vin.push_back(txin);
+    }
+    for (const PSBTOutput& output : outputs) {
+        CTxOut txout;
+        txout.nValue = *output.amount;
+        txout.scriptPubKey = *output.script;
+        mtx.vout.push_back(txout);
+    }
+    return mtx;
+}
+
 bool PartiallySignedTransaction::AddInput(const CTxIn& txin, PSBTInput& psbtin)
 {
     if (std::find(tx->vin.begin(), tx->vin.end(), txin) != tx->vin.end()) {
diff --git a/src/psbt.h b/src/psbt.h
index 112b681363..e1ea4704c9 100644
--- a/src/psbt.h
+++ b/src/psbt.h
@@ -1134,6 +1134,7 @@ struct PartiallySignedTransaction
     void SetupFromTx(const CMutableTransaction& tx);
     void CacheUnsignedTxPieces();
     bool ComputeTimeLock(uint32_t& locktime) const;
+    CMutableTransaction GetUnsignedTx() const;
     PartiallySignedTransaction() {}
     explicit PartiallySignedTransaction(const CMutableTransaction& tx);
 
-- 
2.36.1


From 9f080dc894b6095fd6a521fb6908ddce5de92b53 Mon Sep 17 00:00:00 2001
From: Andrew Chow <achow101-github@achow101.com>
Date: Mon, 11 Jan 2021 15:51:44 -0500
Subject: [PATCH 29/48] Add PSBT::GetUniqueID

The unique ID for PSBTv2 is different from v0. Use this function to get
the ID without requiring the caller to know the version number.
---
 src/psbt.cpp | 19 ++++++++++++++++++-
 src/psbt.h   |  1 +
 2 files changed, 19 insertions(+), 1 deletion(-)

diff --git a/src/psbt.cpp b/src/psbt.cpp
index 823bc5ce8c..2d8c93dafd 100644
--- a/src/psbt.cpp
+++ b/src/psbt.cpp
@@ -24,7 +24,7 @@ bool PartiallySignedTransaction::IsNull() const
 bool PartiallySignedTransaction::Merge(const PartiallySignedTransaction& psbt)
 {
     // Prohibited to merge two PSBTs over different transactions
-    if (tx->GetHash() != psbt.tx->GetHash()) {
+    if (GetUniqueID() != psbt.GetUniqueID()) {
         return false;
     }
 
@@ -108,6 +108,23 @@ CMutableTransaction PartiallySignedTransaction::GetUnsignedTx() const
     return mtx;
 }
 
+uint256 PartiallySignedTransaction::GetUniqueID() const
+{
+    if (tx != std::nullopt) {
+        return tx->GetHash();
+    }
+
+    // Get the unsigned transaction
+    CMutableTransaction mtx = GetUnsignedTx();
+    // Set the locktime to 0
+    mtx.nLockTime = 0;
+    // Set the sequence numbers to 0
+    for (CTxIn& txin : mtx.vin) {
+        txin.nSequence = 0;
+    }
+    return mtx.GetHash();
+}
+
 bool PartiallySignedTransaction::AddInput(const CTxIn& txin, PSBTInput& psbtin)
 {
     if (std::find(tx->vin.begin(), tx->vin.end(), txin) != tx->vin.end()) {
diff --git a/src/psbt.h b/src/psbt.h
index e1ea4704c9..c9be566f76 100644
--- a/src/psbt.h
+++ b/src/psbt.h
@@ -1135,6 +1135,7 @@ struct PartiallySignedTransaction
     void CacheUnsignedTxPieces();
     bool ComputeTimeLock(uint32_t& locktime) const;
     CMutableTransaction GetUnsignedTx() const;
+    uint256 GetUniqueID() const;
     PartiallySignedTransaction() {}
     explicit PartiallySignedTransaction(const CMutableTransaction& tx);
 
-- 
2.36.1


From f9d1cf129d582d964a973d163a1703e6793af9e4 Mon Sep 17 00:00:00 2001
From: Andrew Chow <achow101-github@achow101.com>
Date: Mon, 11 Jan 2021 16:50:58 -0500
Subject: [PATCH 30/48] Change PSBT::AddInput to take just PSBTInput

---
 src/psbt.cpp               | 31 +++++++++++++++++++++++--------
 src/psbt.h                 |  2 +-
 src/rpc/rawtransaction.cpp |  4 ++--
 src/test/fuzz/psbt.cpp     |  4 ++--
 4 files changed, 28 insertions(+), 13 deletions(-)

diff --git a/src/psbt.cpp b/src/psbt.cpp
index 2d8c93dafd..d36322e5b0 100644
--- a/src/psbt.cpp
+++ b/src/psbt.cpp
@@ -125,17 +125,32 @@ uint256 PartiallySignedTransaction::GetUniqueID() const
     return mtx.GetHash();
 }
 
-bool PartiallySignedTransaction::AddInput(const CTxIn& txin, PSBTInput& psbtin)
+bool PartiallySignedTransaction::AddInput(PSBTInput& psbtin)
 {
-    if (std::find(tx->vin.begin(), tx->vin.end(), txin) != tx->vin.end()) {
+    if (std::find_if(inputs.begin(), inputs.end(),
+        [psbtin](const PSBTInput& psbt) {
+            return psbt.prev_txid == psbtin.prev_txid && psbt.prev_out == psbtin.prev_out;
+        }
+    ) != inputs.end()) {
         return false;
     }
-    tx->vin.push_back(txin);
-    psbtin.partial_sigs.clear();
-    psbtin.final_script_sig.clear();
-    psbtin.final_script_witness.SetNull();
-    inputs.push_back(psbtin);
-    return true;
+
+    if (tx != std::nullopt) {
+        // This is a v0 psbt, so do the v0 AddInput
+        CTxIn txin(COutPoint(psbtin.prev_txid, *psbtin.prev_out));
+        if (std::find(tx->vin.begin(), tx->vin.end(), txin) != tx->vin.end()) {
+            return false;
+        }
+        tx->vin.push_back(txin);
+        psbtin.partial_sigs.clear();
+        psbtin.final_script_sig.clear();
+        psbtin.final_script_witness.SetNull();
+        inputs.push_back(psbtin);
+        return true;
+    }
+
+    // TODO: Do PSBTv2
+    return false;
 }
 
 bool PartiallySignedTransaction::AddOutput(const CTxOut& txout, const PSBTOutput& psbtout)
diff --git a/src/psbt.h b/src/psbt.h
index c9be566f76..b20a70a475 100644
--- a/src/psbt.h
+++ b/src/psbt.h
@@ -1129,7 +1129,7 @@ struct PartiallySignedTransaction
     /** Merge psbt into this. The two psbts must have the same underlying CTransaction (i.e. the
       * same actual Bitcoin transaction.) Returns true if the merge succeeded, false otherwise. */
     [[nodiscard]] bool Merge(const PartiallySignedTransaction& psbt);
-    bool AddInput(const CTxIn& txin, PSBTInput& psbtin);
+    bool AddInput(PSBTInput& psbtin);
     bool AddOutput(const CTxOut& txout, const PSBTOutput& psbtout);
     void SetupFromTx(const CMutableTransaction& tx);
     void CacheUnsignedTxPieces();
diff --git a/src/rpc/rawtransaction.cpp b/src/rpc/rawtransaction.cpp
index 16ad18a031..4b5c924e02 100644
--- a/src/rpc/rawtransaction.cpp
+++ b/src/rpc/rawtransaction.cpp
@@ -1690,7 +1690,7 @@ static RPCHelpMan joinpsbts()
     // Merge
     for (auto& psbt : psbtxs) {
         for (unsigned int i = 0; i < psbt.tx->vin.size(); ++i) {
-            if (!merged_psbt.AddInput(psbt.tx->vin[i], psbt.inputs[i])) {
+            if (!merged_psbt.AddInput(psbt.inputs[i])) {
                 throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf("Input %s:%d exists in multiple PSBTs", psbt.tx->vin[i].prevout.hash.ToString(), psbt.tx->vin[i].prevout.n));
             }
         }
@@ -1722,7 +1722,7 @@ static RPCHelpMan joinpsbts()
     shuffled_psbt.tx->nVersion = merged_psbt.tx->nVersion;
     shuffled_psbt.tx->nLockTime = merged_psbt.tx->nLockTime;
     for (int i : input_indices) {
-        shuffled_psbt.AddInput(merged_psbt.tx->vin[i], merged_psbt.inputs[i]);
+        shuffled_psbt.AddInput(merged_psbt.inputs[i]);
     }
     for (int i : output_indices) {
         shuffled_psbt.AddOutput(merged_psbt.tx->vout[i], merged_psbt.outputs[i]);
diff --git a/src/test/fuzz/psbt.cpp b/src/test/fuzz/psbt.cpp
index e38b7e97b9..d7f99e84c8 100644
--- a/src/test/fuzz/psbt.cpp
+++ b/src/test/fuzz/psbt.cpp
@@ -89,8 +89,8 @@ FUZZ_TARGET_INIT(psbt, initialize_psbt)
     psbt_mut = psbt;
     (void)CombinePSBTs(psbt_mut, {psbt_mut, psbt_merge});
     psbt_mut = psbt;
-    for (unsigned int i = 0; i < psbt_merge.tx->vin.size(); ++i) {
-        (void)psbt_mut.AddInput(psbt_merge.tx->vin[i], psbt_merge.inputs[i]);
+    for (auto& psbt_in : psbt_merge.inputs) {
+        (void)psbt_mut.AddInput(psbt_in);
     }
     for (unsigned int i = 0; i < psbt_merge.tx->vout.size(); ++i) {
         Assert(psbt_mut.AddOutput(psbt_merge.tx->vout[i], psbt_merge.outputs[i]));
-- 
2.36.1


From 9a3f748172f3c16cdb6fb8f7ed8b583eda4a1745 Mon Sep 17 00:00:00 2001
From: Andrew Chow <achow101-github@achow101.com>
Date: Mon, 11 Jan 2021 16:59:29 -0500
Subject: [PATCH 31/48] Change PSBT::AddOutput to take just PSBTOutput

---
 src/psbt.cpp               | 15 +++++++++++----
 src/psbt.h                 |  2 +-
 src/rpc/rawtransaction.cpp |  4 ++--
 src/test/fuzz/psbt.cpp     |  4 ++--
 4 files changed, 16 insertions(+), 9 deletions(-)

diff --git a/src/psbt.cpp b/src/psbt.cpp
index d36322e5b0..d1bfba0e45 100644
--- a/src/psbt.cpp
+++ b/src/psbt.cpp
@@ -153,11 +153,18 @@ bool PartiallySignedTransaction::AddInput(PSBTInput& psbtin)
     return false;
 }
 
-bool PartiallySignedTransaction::AddOutput(const CTxOut& txout, const PSBTOutput& psbtout)
+bool PartiallySignedTransaction::AddOutput(const PSBTOutput& psbtout)
 {
-    tx->vout.push_back(txout);
-    outputs.push_back(psbtout);
-    return true;
+    if (tx != std::nullopt) {
+        // This is a v0 psbt, do the v0 AddOutput
+        CTxOut txout(*psbtout.amount, *psbtout.script);
+        tx->vout.push_back(txout);
+        outputs.push_back(psbtout);
+        return true;
+    }
+
+    // TOOD: Do PSBTv2
+    return false;
 }
 
 bool PSBTInput::GetUTXO(CTxOut& utxo) const
diff --git a/src/psbt.h b/src/psbt.h
index b20a70a475..de9d6eb6ad 100644
--- a/src/psbt.h
+++ b/src/psbt.h
@@ -1130,7 +1130,7 @@ struct PartiallySignedTransaction
       * same actual Bitcoin transaction.) Returns true if the merge succeeded, false otherwise. */
     [[nodiscard]] bool Merge(const PartiallySignedTransaction& psbt);
     bool AddInput(PSBTInput& psbtin);
-    bool AddOutput(const CTxOut& txout, const PSBTOutput& psbtout);
+    bool AddOutput(const PSBTOutput& psbtout);
     void SetupFromTx(const CMutableTransaction& tx);
     void CacheUnsignedTxPieces();
     bool ComputeTimeLock(uint32_t& locktime) const;
diff --git a/src/rpc/rawtransaction.cpp b/src/rpc/rawtransaction.cpp
index 4b5c924e02..3b99792c21 100644
--- a/src/rpc/rawtransaction.cpp
+++ b/src/rpc/rawtransaction.cpp
@@ -1695,7 +1695,7 @@ static RPCHelpMan joinpsbts()
             }
         }
         for (unsigned int i = 0; i < psbt.tx->vout.size(); ++i) {
-            merged_psbt.AddOutput(psbt.tx->vout[i], psbt.outputs[i]);
+            merged_psbt.AddOutput(psbt.outputs[i]);
         }
         for (auto& xpub_pair : psbt.m_xpubs) {
             if (merged_psbt.m_xpubs.count(xpub_pair.first) == 0) {
@@ -1725,7 +1725,7 @@ static RPCHelpMan joinpsbts()
         shuffled_psbt.AddInput(merged_psbt.inputs[i]);
     }
     for (int i : output_indices) {
-        shuffled_psbt.AddOutput(merged_psbt.tx->vout[i], merged_psbt.outputs[i]);
+        shuffled_psbt.AddOutput(merged_psbt.outputs[i]);
     }
     shuffled_psbt.unknown.insert(merged_psbt.unknown.begin(), merged_psbt.unknown.end());
 
diff --git a/src/test/fuzz/psbt.cpp b/src/test/fuzz/psbt.cpp
index d7f99e84c8..86fbefaecf 100644
--- a/src/test/fuzz/psbt.cpp
+++ b/src/test/fuzz/psbt.cpp
@@ -92,8 +92,8 @@ FUZZ_TARGET_INIT(psbt, initialize_psbt)
     for (auto& psbt_in : psbt_merge.inputs) {
         (void)psbt_mut.AddInput(psbt_in);
     }
-    for (unsigned int i = 0; i < psbt_merge.tx->vout.size(); ++i) {
-        Assert(psbt_mut.AddOutput(psbt_merge.tx->vout[i], psbt_merge.outputs[i]));
+    for (const auto& psbt_out : psbt_merge.outputs) {
+        Assert(psbt_mut.AddOutput(psbt_out));
     }
     psbt_mut.unknown.insert(psbt_merge.unknown.begin(), psbt_merge.unknown.end());
 }
-- 
2.36.1


From c3566015d6e436e8ddb1913753c875b7b67fcb8d Mon Sep 17 00:00:00 2001
From: Andrew Chow <achow101-github@achow101.com>
Date: Mon, 11 Jan 2021 17:18:31 -0500
Subject: [PATCH 32/48] Implement PSBTv2 field merging

---
 src/psbt.cpp | 12 ++++++++++++
 1 file changed, 12 insertions(+)

diff --git a/src/psbt.cpp b/src/psbt.cpp
index d1bfba0e45..4cbe580bbc 100644
--- a/src/psbt.cpp
+++ b/src/psbt.cpp
@@ -28,6 +28,7 @@ bool PartiallySignedTransaction::Merge(const PartiallySignedTransaction& psbt)
         return false;
     }
 
+    assert(*tx_version == psbt.tx_version);
     for (unsigned int i = 0; i < inputs.size(); ++i) {
         inputs[i].Merge(psbt.inputs[i]);
     }
@@ -41,6 +42,8 @@ bool PartiallySignedTransaction::Merge(const PartiallySignedTransaction& psbt)
             m_xpubs[xpub_pair.first].insert(xpub_pair.second.begin(), xpub_pair.second.end());
         }
     }
+    if (fallback_locktime == std::nullopt && psbt.fallback_locktime != std::nullopt) fallback_locktime = psbt.fallback_locktime;
+    if (m_tx_modifiable == std::nullopt && psbt.m_tx_modifiable != std::nullopt) m_tx_modifiable = psbt.m_tx_modifiable;
     unknown.insert(psbt.unknown.begin(), psbt.unknown.end());
 
     return true;
@@ -283,6 +286,9 @@ void PSBTInput::FromSignatureData(const SignatureData& sigdata)
 
 void PSBTInput::Merge(const PSBTInput& input)
 {
+    assert(prev_txid == input.prev_txid);
+    assert(*prev_out == *input.prev_out);
+
     if (!non_witness_utxo && input.non_witness_utxo) non_witness_utxo = input.non_witness_utxo;
     if (witness_utxo.IsNull() && !input.witness_utxo.IsNull()) {
         witness_utxo = input.witness_utxo;
@@ -306,6 +312,9 @@ void PSBTInput::Merge(const PSBTInput& input)
     if (m_tap_key_sig.empty() && !input.m_tap_key_sig.empty()) m_tap_key_sig = input.m_tap_key_sig;
     if (m_tap_internal_key.IsNull() && !input.m_tap_internal_key.IsNull()) m_tap_internal_key = input.m_tap_internal_key;
     if (m_tap_merkle_root.IsNull() && !input.m_tap_merkle_root.IsNull()) m_tap_merkle_root = input.m_tap_merkle_root;
+    if (sequence == std::nullopt && input.sequence != std::nullopt) sequence = input.sequence;
+    if (time_locktime == std::nullopt && input.time_locktime != std::nullopt) time_locktime = input.time_locktime;
+    if (height_locktime == std::nullopt && input.height_locktime != std::nullopt) height_locktime = input.height_locktime;
 }
 
 void PSBTOutput::FillSignatureData(SignatureData& sigdata) const
@@ -360,6 +369,9 @@ bool PSBTOutput::IsNull() const
 
 void PSBTOutput::Merge(const PSBTOutput& output)
 {
+    assert(*amount == *output.amount);
+    assert(*script == *output.script);
+
     hd_keypaths.insert(output.hd_keypaths.begin(), output.hd_keypaths.end());
     unknown.insert(output.unknown.begin(), output.unknown.end());
     m_tap_bip32_paths.insert(output.m_tap_bip32_paths.begin(), output.m_tap_bip32_paths.end());
-- 
2.36.1


From 646a629a2ea966bf68652e74b19206060741a094 Mon Sep 17 00:00:00 2001
From: Andrew Chow <achow101-github@achow101.com>
Date: Mon, 11 Jan 2021 17:48:30 -0500
Subject: [PATCH 33/48] Add PSBTInput::GetOutPoint

Helper for getting the PSBTInput COutPoint
---
 src/psbt.cpp | 5 +++++
 src/psbt.h   | 1 +
 2 files changed, 6 insertions(+)

diff --git a/src/psbt.cpp b/src/psbt.cpp
index 4cbe580bbc..f4a2bd001c 100644
--- a/src/psbt.cpp
+++ b/src/psbt.cpp
@@ -188,6 +188,11 @@ bool PSBTInput::GetUTXO(CTxOut& utxo) const
     return true;
 }
 
+COutPoint PSBTInput::GetOutPoint() const
+{
+    return COutPoint(prev_txid, *prev_out);
+}
+
 bool PSBTInput::IsNull() const
 {
     return !non_witness_utxo && witness_utxo.IsNull() && partial_sigs.empty() && unknown.empty() && hd_keypaths.empty() && redeem_script.empty() && witness_script.empty();
diff --git a/src/psbt.h b/src/psbt.h
index de9d6eb6ad..9165bcf4a5 100644
--- a/src/psbt.h
+++ b/src/psbt.h
@@ -249,6 +249,7 @@ struct PSBTInput
      * @return Whether the UTXO could be retrieved
      */
     bool GetUTXO(CTxOut& utxo) const;
+    COutPoint GetOutPoint() const;
     PSBTInput(uint32_t version) : m_psbt_version(version) {}
 
     template <typename Stream>
-- 
2.36.1


From 1d41aeac1d458159f507b3fcb99c64979f91311e Mon Sep 17 00:00:00 2001
From: Andrew Chow <achow101-github@achow101.com>
Date: Mon, 11 Jan 2021 17:18:54 -0500
Subject: [PATCH 34/48] Update SignPSBTInput for PSBTv2

---
 src/psbt.cpp | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/src/psbt.cpp b/src/psbt.cpp
index f4a2bd001c..81cf394baf 100644
--- a/src/psbt.cpp
+++ b/src/psbt.cpp
@@ -442,7 +442,7 @@ PrecomputedTransactionData PrecomputePSBTData(const PartiallySignedTransaction&
 bool SignPSBTInput(const SigningProvider& provider, PartiallySignedTransaction& psbt, int index, const PrecomputedTransactionData* txdata, int sighash,  SignatureData* out_sigdata, bool finalize)
 {
     PSBTInput& input = psbt.inputs.at(index);
-    const CMutableTransaction& tx = *psbt.tx;
+    const CMutableTransaction& tx = psbt.GetUnsignedTx();
 
     if (PSBTInputSigned(input)) {
         return true;
@@ -458,7 +458,7 @@ bool SignPSBTInput(const SigningProvider& provider, PartiallySignedTransaction&
 
     if (input.non_witness_utxo) {
         // If we're taking our information from a non-witness UTXO, verify that it matches the prevout.
-        COutPoint prevout = tx.vin[index].prevout;
+        COutPoint prevout = input.GetOutPoint();
         if (prevout.n >= input.non_witness_utxo->vout.size()) {
             return false;
         }
-- 
2.36.1


From 07f944a5f3f5e305feb2206f850faba2391f1db6 Mon Sep 17 00:00:00 2001
From: Andrew Chow <achow101-github@achow101.com>
Date: Fri, 18 Jun 2021 19:12:26 -0400
Subject: [PATCH 35/48] Change PrecomputePSBTData to use GetUnsignedTx

---
 src/psbt.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/psbt.cpp b/src/psbt.cpp
index 81cf394baf..298de9f29e 100644
--- a/src/psbt.cpp
+++ b/src/psbt.cpp
@@ -424,7 +424,7 @@ void UpdatePSBTOutput(const SigningProvider& provider, PartiallySignedTransactio
 
 PrecomputedTransactionData PrecomputePSBTData(const PartiallySignedTransaction& psbt)
 {
-    const CMutableTransaction& tx = *psbt.tx;
+    const CMutableTransaction& tx = psbt.GetUnsignedTx();
     bool have_all_spent_outputs = true;
     std::vector<CTxOut> utxos;
     for (const PSBTInput& input : psbt.inputs) {
-- 
2.36.1


From 346ef3594b2f4dbb836ccc92936465783e8ee974 Mon Sep 17 00:00:00 2001
From: Andrew Chow <achow101-github@achow101.com>
Date: Mon, 11 Jan 2021 17:19:06 -0500
Subject: [PATCH 36/48] Update FinalizeAndExtract for v2

---
 src/psbt.cpp | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/src/psbt.cpp b/src/psbt.cpp
index 298de9f29e..3627ca53f9 100644
--- a/src/psbt.cpp
+++ b/src/psbt.cpp
@@ -520,7 +520,7 @@ bool FinalizePSBT(PartiallySignedTransaction& psbtx)
     //   script.
     bool complete = true;
     const PrecomputedTransactionData txdata = PrecomputePSBTData(psbtx);
-    for (unsigned int i = 0; i < psbtx.tx->vin.size(); ++i) {
+    for (unsigned int i = 0; i < psbtx.inputs.size(); ++i) {
         complete &= SignPSBTInput(DUMMY_SIGNING_PROVIDER, psbtx, i, &txdata, SIGHASH_ALL, nullptr, true);
     }
 
@@ -535,7 +535,7 @@ bool FinalizeAndExtractPSBT(PartiallySignedTransaction& psbtx, CMutableTransacti
         return false;
     }
 
-    result = *psbtx.tx;
+    result = psbtx.GetUnsignedTx();
     for (unsigned int i = 0; i < result.vin.size(); ++i) {
         result.vin[i].scriptSig = psbtx.inputs[i].final_script_sig;
         result.vin[i].scriptWitness = psbtx.inputs[i].final_script_witness;
-- 
2.36.1


From d14a06bbfb5b94cb7d7f6c075b764635cdaad2b3 Mon Sep 17 00:00:00 2001
From: Andrew Chow <achow101-github@achow101.com>
Date: Mon, 11 Jan 2021 17:21:34 -0500
Subject: [PATCH 37/48] Update AnalyzePSBT for PSBTv2

---
 src/node/psbt.cpp | 22 +++++++++++-----------
 1 file changed, 11 insertions(+), 11 deletions(-)

diff --git a/src/node/psbt.cpp b/src/node/psbt.cpp
index eca2da5fd4..888d298465 100644
--- a/src/node/psbt.cpp
+++ b/src/node/psbt.cpp
@@ -22,11 +22,11 @@ PSBTAnalysis AnalyzePSBT(PartiallySignedTransaction psbtx)
 
     CAmount in_amt = 0;
 
-    result.inputs.resize(psbtx.tx->vin.size());
+    result.inputs.resize(psbtx.inputs.size());
 
     const PrecomputedTransactionData txdata = PrecomputePSBTData(psbtx);
 
-    for (unsigned int i = 0; i < psbtx.tx->vin.size(); ++i) {
+    for (unsigned int i = 0; i < psbtx.inputs.size(); ++i) {
         PSBTInput& input = psbtx.inputs[i];
         PSBTInputAnalysis& input_analysis = result.inputs[i];
 
@@ -43,7 +43,7 @@ PSBTAnalysis AnalyzePSBT(PartiallySignedTransaction psbtx)
             in_amt += utxo.nValue;
             input_analysis.has_utxo = true;
         } else {
-            if (input.non_witness_utxo && psbtx.tx->vin[i].prevout.n >= input.non_witness_utxo->vout.size()) {
+            if (input.non_witness_utxo && input.prev_out >= input.non_witness_utxo->vout.size()) {
                 result.SetInvalid(strprintf("PSBT is not valid. Input %u specifies invalid prevout", i));
                 return result;
             }
@@ -89,7 +89,7 @@ PSBTAnalysis AnalyzePSBT(PartiallySignedTransaction psbtx)
 
     // Calculate next role for PSBT by grabbing "minimum" PSBTInput next role
     result.next = PSBTRole::EXTRACTOR;
-    for (unsigned int i = 0; i < psbtx.tx->vin.size(); ++i) {
+    for (unsigned int i = 0; i < psbtx.inputs.size(); ++i) {
         PSBTInputAnalysis& input_analysis = result.inputs[i];
         result.next = std::min(result.next, input_analysis.next);
     }
@@ -97,12 +97,12 @@ PSBTAnalysis AnalyzePSBT(PartiallySignedTransaction psbtx)
 
     if (calc_fee) {
         // Get the output amount
-        CAmount out_amt = std::accumulate(psbtx.tx->vout.begin(), psbtx.tx->vout.end(), CAmount(0),
-            [](CAmount a, const CTxOut& b) {
-                if (!MoneyRange(a) || !MoneyRange(b.nValue) || !MoneyRange(a + b.nValue)) {
+        CAmount out_amt = std::accumulate(psbtx.outputs.begin(), psbtx.outputs.end(), CAmount(0),
+            [](CAmount a, const PSBTOutput& b) {
+                if (!MoneyRange(a) || !MoneyRange(*b.amount) || !MoneyRange(a + *b.amount)) {
                     return CAmount(-1);
                 }
-                return a += b.nValue;
+                return a += *b.amount;
             }
         );
         if (!MoneyRange(out_amt)) {
@@ -115,12 +115,12 @@ PSBTAnalysis AnalyzePSBT(PartiallySignedTransaction psbtx)
         result.fee = fee;
 
         // Estimate the size
-        CMutableTransaction mtx(*psbtx.tx);
+        CMutableTransaction mtx(psbtx.GetUnsignedTx());
         CCoinsView view_dummy;
         CCoinsViewCache view(&view_dummy);
         bool success = true;
 
-        for (unsigned int i = 0; i < psbtx.tx->vin.size(); ++i) {
+        for (unsigned int i = 0; i < psbtx.inputs.size(); ++i) {
             PSBTInput& input = psbtx.inputs[i];
             Coin newcoin;
 
@@ -131,7 +131,7 @@ PSBTAnalysis AnalyzePSBT(PartiallySignedTransaction psbtx)
                 mtx.vin[i].scriptSig = input.final_script_sig;
                 mtx.vin[i].scriptWitness = input.final_script_witness;
                 newcoin.nHeight = 1;
-                view.AddCoin(psbtx.tx->vin[i].prevout, std::move(newcoin), true);
+                view.AddCoin(input.GetOutPoint(), std::move(newcoin), true);
             }
         }
 
-- 
2.36.1


From d654e724541fe360ed7541686693994d29834ddb Mon Sep 17 00:00:00 2001
From: Andrew Chow <achow101-github@achow101.com>
Date: Mon, 11 Jan 2021 17:59:22 -0500
Subject: [PATCH 38/48] Update PSBT Operations Dialog for v2

---
 src/qt/psbtoperationsdialog.cpp | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/src/qt/psbtoperationsdialog.cpp b/src/qt/psbtoperationsdialog.cpp
index 333766ce21..69b702351d 100644
--- a/src/qt/psbtoperationsdialog.cpp
+++ b/src/qt/psbtoperationsdialog.cpp
@@ -176,12 +176,12 @@ std::string PSBTOperationsDialog::renderTransaction(const PartiallySignedTransac
 {
     QString tx_description = "";
     CAmount totalAmount = 0;
-    for (const CTxOut& out : psbtx.tx->vout) {
+    for (const PSBTOutput& out : psbtx.outputs) {
         CTxDestination address;
-        ExtractDestination(out.scriptPubKey, address);
-        totalAmount += out.nValue;
+        ExtractDestination(*out.script, address);
+        totalAmount += *out.amount;
         tx_description.append(tr(" * Sends %1 to %2")
-            .arg(BitcoinUnits::formatWithUnit(BitcoinUnit::BTC, out.nValue))
+            .arg(BitcoinUnits::formatWithUnit(BitcoinUnit::BTC, *out.amount))
             .arg(QString::fromStdString(EncodeDestination(address))));
         tx_description.append("<br>");
     }
-- 
2.36.1


From 050bb2909feb5eef6cea3136d9330e2661a29d4f Mon Sep 17 00:00:00 2001
From: Andrew Chow <achow101-github@achow101.com>
Date: Mon, 11 Jan 2021 18:00:22 -0500
Subject: [PATCH 39/48] Update RPCs for PSBTv2

---
 src/rpc/rawtransaction.cpp | 50 ++++++++++++++++++++++----------------
 1 file changed, 29 insertions(+), 21 deletions(-)

diff --git a/src/rpc/rawtransaction.cpp b/src/rpc/rawtransaction.cpp
index 3b99792c21..3150426159 100644
--- a/src/rpc/rawtransaction.cpp
+++ b/src/rpc/rawtransaction.cpp
@@ -926,10 +926,12 @@ static RPCHelpMan decodepsbt()
 
     UniValue result(UniValue::VOBJ);
 
-    // Add the decoded tx
-    UniValue tx_univ(UniValue::VOBJ);
-    TxToUniv(CTransaction(*psbtx.tx), /*block_hash=*/uint256(), /*entry=*/tx_univ, /*include_hex=*/false);
-    result.pushKV("tx", tx_univ);
+    if (psbtx.tx != std::nullopt) {
+        // Add the decoded tx
+        UniValue tx_univ(UniValue::VOBJ);
+        TxToUniv(CTransaction(*psbtx.tx), /*block_hash=*/uint256(), /*entry=*/tx_univ, /*include_hex=*/false);
+        result.pushKV("tx", tx_univ);
+    }
 
     // Add the global xpubs
     UniValue global_xpubs(UniValue::VARR);
@@ -995,7 +997,7 @@ static RPCHelpMan decodepsbt()
             have_a_utxo = true;
         }
         if (input.non_witness_utxo) {
-            txout = input.non_witness_utxo->vout[psbtx.tx->vin[i].prevout.n];
+            txout = input.non_witness_utxo->vout[*input.prev_out];
 
             UniValue non_wit(UniValue::VOBJ);
             TxToUniv(*input.non_witness_utxo, /*block_hash=*/uint256(), /*entry=*/non_wit, /*include_hex=*/false);
@@ -1296,8 +1298,8 @@ static RPCHelpMan decodepsbt()
         outputs.push_back(out);
 
         // Fee calculation
-        if (MoneyRange(psbtx.tx->vout[i].nValue) && MoneyRange(output_value + psbtx.tx->vout[i].nValue)) {
-            output_value += psbtx.tx->vout[i].nValue;
+        if (MoneyRange(*output.amount) && MoneyRange(output_value + *output.amount)) {
+            output_value += *output.amount;
         } else {
             // Hack to just not show fee later
             have_all_utxos = false;
@@ -1593,8 +1595,8 @@ static RPCHelpMan utxoupdatepsbt()
         CCoinsViewMemPool viewMempool(&viewChain, mempool);
         view.SetBackend(viewMempool); // temporarily switch cache backend to db+mempool view
 
-        for (const CTxIn& txin : psbtx.tx->vin) {
-            view.AccessCoin(txin.prevout); // Load entries from viewChain into view; can fail.
+        for (const PSBTInput& txin : psbtx.inputs) {
+            view.AccessCoin(txin.GetOutPoint()); // Load entries from viewChain into view; can fail.
         }
 
         view.SetBackend(viewDummy); // switch back to avoid locking mempool for too long
@@ -1602,14 +1604,14 @@ static RPCHelpMan utxoupdatepsbt()
 
     // Fill the inputs
     const PrecomputedTransactionData txdata = PrecomputePSBTData(psbtx);
-    for (unsigned int i = 0; i < psbtx.tx->vin.size(); ++i) {
+    for (unsigned int i = 0; i < psbtx.inputs.size(); ++i) {
         PSBTInput& input = psbtx.inputs.at(i);
 
         if (input.non_witness_utxo || !input.witness_utxo.IsNull()) {
             continue;
         }
 
-        const Coin& coin = view.AccessCoin(psbtx.tx->vin[i].prevout);
+        const Coin& coin = view.AccessCoin(input.GetOutPoint());
 
         if (IsSegWitOutput(provider, coin.out.scriptPubKey)) {
             input.witness_utxo = coin.out;
@@ -1622,7 +1624,7 @@ static RPCHelpMan utxoupdatepsbt()
     }
 
     // Update script/keypath information using descriptor data.
-    for (unsigned int i = 0; i < psbtx.tx->vout.size(); ++i) {
+    for (unsigned int i = 0; i < psbtx.outputs.size(); ++i) {
         UpdatePSBTOutput(public_provider, psbtx, i);
     }
 
@@ -1662,7 +1664,7 @@ static RPCHelpMan joinpsbts()
         throw JSONRPCError(RPC_INVALID_PARAMETER, "At least two PSBTs are required to join PSBTs.");
     }
 
-    uint32_t best_version = 1;
+    int32_t best_version = 1;
     uint32_t best_locktime = 0xffffffff;
     for (unsigned int i = 0; i < txs.size(); ++i) {
         PartiallySignedTransaction psbtx;
@@ -1672,29 +1674,32 @@ static RPCHelpMan joinpsbts()
         }
         psbtxs.push_back(psbtx);
         // Choose the highest version number
-        if (static_cast<uint32_t>(psbtx.tx->nVersion) > best_version) {
-            best_version = static_cast<uint32_t>(psbtx.tx->nVersion);
+        if (*psbtx.tx_version > best_version) {
+            best_version = *psbtx.tx_version;
         }
         // Choose the lowest lock time
-        if (psbtx.tx->nLockTime < best_locktime) {
-            best_locktime = psbtx.tx->nLockTime;
+        if (*psbtx.fallback_locktime < best_locktime) {
+            best_locktime = *psbtx.fallback_locktime;
         }
     }
 
     // Create a blank psbt where everything will be added
     PartiallySignedTransaction merged_psbt;
+    merged_psbt.tx_version = best_version;
+    merged_psbt.fallback_locktime = best_locktime;
+    // TODO: Remove for PSBTv2
     merged_psbt.tx = CMutableTransaction();
-    merged_psbt.tx->nVersion = static_cast<int32_t>(best_version);
+    merged_psbt.tx->nVersion = best_version;
     merged_psbt.tx->nLockTime = best_locktime;
 
     // Merge
     for (auto& psbt : psbtxs) {
-        for (unsigned int i = 0; i < psbt.tx->vin.size(); ++i) {
+        for (unsigned int i = 0; i < psbt.inputs.size(); ++i) {
             if (!merged_psbt.AddInput(psbt.inputs[i])) {
-                throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf("Input %s:%d exists in multiple PSBTs", psbt.tx->vin[i].prevout.hash.ToString(), psbt.tx->vin[i].prevout.n));
+                throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf("Input %s:%d exists in multiple PSBTs", psbt.inputs[i].prev_txid.ToString(), *psbt.inputs[i].prev_out));
             }
         }
-        for (unsigned int i = 0; i < psbt.tx->vout.size(); ++i) {
+        for (unsigned int i = 0; i < psbt.outputs.size(); ++i) {
             merged_psbt.AddOutput(psbt.outputs[i]);
         }
         for (auto& xpub_pair : psbt.m_xpubs) {
@@ -1718,6 +1723,9 @@ static RPCHelpMan joinpsbts()
     Shuffle(output_indices.begin(), output_indices.end(), FastRandomContext());
 
     PartiallySignedTransaction shuffled_psbt;
+    shuffled_psbt.tx_version = merged_psbt.tx_version;
+    shuffled_psbt.fallback_locktime = merged_psbt.fallback_locktime;
+    // TODO: Remove for PSBTv2
     shuffled_psbt.tx = CMutableTransaction();
     shuffled_psbt.tx->nVersion = merged_psbt.tx->nVersion;
     shuffled_psbt.tx->nLockTime = merged_psbt.tx->nLockTime;
-- 
2.36.1


From 117f6d045cb2ee2f6342e8f403d53bca3c96de72 Mon Sep 17 00:00:00 2001
From: Andrew Chow <achow101-github@achow101.com>
Date: Mon, 11 Jan 2021 18:00:54 -0500
Subject: [PATCH 40/48] Update wallet for PSBTv2

---
 src/wallet/scriptpubkeyman.cpp        | 18 ++++++++----------
 src/wallet/test/psbt_wallet_tests.cpp |  1 +
 src/wallet/wallet.cpp                 |  7 ++-----
 3 files changed, 11 insertions(+), 15 deletions(-)

diff --git a/src/wallet/scriptpubkeyman.cpp b/src/wallet/scriptpubkeyman.cpp
index 1fec82a485..d144b5d9c2 100644
--- a/src/wallet/scriptpubkeyman.cpp
+++ b/src/wallet/scriptpubkeyman.cpp
@@ -631,8 +631,7 @@ TransactionError LegacyScriptPubKeyMan::FillPSBT(PartiallySignedTransaction& psb
     if (n_signed) {
         *n_signed = 0;
     }
-    for (unsigned int i = 0; i < psbtx.tx->vin.size(); ++i) {
-        const CTxIn& txin = psbtx.tx->vin[i];
+    for (unsigned int i = 0; i < psbtx.inputs.size(); ++i) {
         PSBTInput& input = psbtx.inputs.at(i);
 
         if (PSBTInputSigned(input)) {
@@ -646,7 +645,7 @@ TransactionError LegacyScriptPubKeyMan::FillPSBT(PartiallySignedTransaction& psb
 
         // Check non_witness_utxo has specified prevout
         if (input.non_witness_utxo) {
-            if (txin.prevout.n >= input.non_witness_utxo->vout.size()) {
+            if (*input.prev_out >= input.non_witness_utxo->vout.size()) {
                 return TransactionError::MISSING_INPUTS;
             }
         } else if (input.witness_utxo.IsNull()) {
@@ -667,7 +666,7 @@ TransactionError LegacyScriptPubKeyMan::FillPSBT(PartiallySignedTransaction& psb
     }
 
     // Fill in the bip32 keypaths and redeemscripts for the outputs so that hardware wallets can identify change
-    for (unsigned int i = 0; i < psbtx.tx->vout.size(); ++i) {
+    for (unsigned int i = 0; i < psbtx.outputs.size(); ++i) {
         UpdatePSBTOutput(HidingSigningProvider(this, true, !bip32derivs), psbtx, i);
     }
 
@@ -2137,8 +2136,7 @@ TransactionError DescriptorScriptPubKeyMan::FillPSBT(PartiallySignedTransaction&
     if (n_signed) {
         *n_signed = 0;
     }
-    for (unsigned int i = 0; i < psbtx.tx->vin.size(); ++i) {
-        const CTxIn& txin = psbtx.tx->vin[i];
+    for (unsigned int i = 0; i < psbtx.inputs.size(); ++i) {
         PSBTInput& input = psbtx.inputs.at(i);
 
         if (PSBTInputSigned(input)) {
@@ -2155,10 +2153,10 @@ TransactionError DescriptorScriptPubKeyMan::FillPSBT(PartiallySignedTransaction&
         if (!input.witness_utxo.IsNull()) {
             script = input.witness_utxo.scriptPubKey;
         } else if (input.non_witness_utxo) {
-            if (txin.prevout.n >= input.non_witness_utxo->vout.size()) {
+            if (*input.prev_out >= input.non_witness_utxo->vout.size()) {
                 return TransactionError::MISSING_INPUTS;
             }
-            script = input.non_witness_utxo->vout[txin.prevout.n].scriptPubKey;
+            script = input.non_witness_utxo->vout[*input.prev_out].scriptPubKey;
         } else {
             // There's no UTXO so we can just skip this now
             continue;
@@ -2207,8 +2205,8 @@ TransactionError DescriptorScriptPubKeyMan::FillPSBT(PartiallySignedTransaction&
     }
 
     // Fill in the bip32 keypaths and redeemscripts for the outputs so that hardware wallets can identify change
-    for (unsigned int i = 0; i < psbtx.tx->vout.size(); ++i) {
-        std::unique_ptr<SigningProvider> keys = GetSolvingProvider(psbtx.tx->vout.at(i).scriptPubKey);
+    for (unsigned int i = 0; i < psbtx.outputs.size(); ++i) {
+        std::unique_ptr<SigningProvider> keys = GetSolvingProvider(*psbtx.outputs.at(i).script);
         if (!keys) {
             continue;
         }
diff --git a/src/wallet/test/psbt_wallet_tests.cpp b/src/wallet/test/psbt_wallet_tests.cpp
index 62053ae8d2..1dfe8db39d 100644
--- a/src/wallet/test/psbt_wallet_tests.cpp
+++ b/src/wallet/test/psbt_wallet_tests.cpp
@@ -64,6 +64,7 @@ BOOST_AUTO_TEST_CASE(psbt_updater_test)
 
     // Mutate the transaction so that one of the inputs is invalid
     psbtx.tx->vin[0].prevout.n = 2;
+    psbtx.inputs[0].prev_out = 2;
 
     // Try to sign the mutated input
     SignatureData sigdata;
diff --git a/src/wallet/wallet.cpp b/src/wallet/wallet.cpp
index aafbf341ff..eef55c28f0 100644
--- a/src/wallet/wallet.cpp
+++ b/src/wallet/wallet.cpp
@@ -1981,17 +1981,14 @@ TransactionError CWallet::FillPSBT(PartiallySignedTransaction& psbtx, bool& comp
     const PrecomputedTransactionData txdata = PrecomputePSBTData(psbtx);
     LOCK(cs_wallet);
     // Get all of the previous transactions
-    for (unsigned int i = 0; i < psbtx.tx->vin.size(); ++i) {
-        const CTxIn& txin = psbtx.tx->vin[i];
-        PSBTInput& input = psbtx.inputs.at(i);
-
+    for (PSBTInput& input : psbtx.inputs) {
         if (PSBTInputSigned(input)) {
             continue;
         }
 
         // If we have no utxo, grab it from the wallet.
         if (!input.non_witness_utxo) {
-            const uint256& txhash = txin.prevout.hash;
+            const uint256& txhash = input.prev_txid;
             const auto it = mapWallet.find(txhash);
             if (it != mapWallet.end()) {
                 const CWalletTx& wtx = it->second;
-- 
2.36.1


From 0bd4b7e75c38674d4881fcf8cbff2e735266e7ea Mon Sep 17 00:00:00 2001
From: Andrew Chow <achow101-github@achow101.com>
Date: Mon, 18 Jan 2021 15:27:05 -0500
Subject: [PATCH 41/48] Implement PSBTv2 AddInput and AddOutput

---
 src/psbt.cpp | 78 ++++++++++++++++++++++++++++++++++++++++++++++++----
 1 file changed, 73 insertions(+), 5 deletions(-)

diff --git a/src/psbt.cpp b/src/psbt.cpp
index 3627ca53f9..67d9c608f6 100644
--- a/src/psbt.cpp
+++ b/src/psbt.cpp
@@ -130,7 +130,10 @@ uint256 PartiallySignedTransaction::GetUniqueID() const
 
 bool PartiallySignedTransaction::AddInput(PSBTInput& psbtin)
 {
-    if (std::find_if(inputs.begin(), inputs.end(),
+    // Check required fields are present and this input is not a duplicate
+    if (psbtin.prev_txid.IsNull() ||
+        psbtin.prev_out == std::nullopt ||
+        std::find_if(inputs.begin(), inputs.end(),
         [psbtin](const PSBTInput& psbt) {
             return psbt.prev_txid == psbtin.prev_txid && psbt.prev_out == psbtin.prev_out;
         }
@@ -152,12 +155,71 @@ bool PartiallySignedTransaction::AddInput(PSBTInput& psbtin)
         return true;
     }
 
-    // TODO: Do PSBTv2
-    return false;
+    // No global tx, must be PSBTv2.
+    // Check inputs modifiable flag
+    if (m_tx_modifiable == std::nullopt || !m_tx_modifiable->test(0)) {
+        return false;
+    }
+
+    // Determine if we need to iterate the inputs.
+    // For now, we only do this if the new input has a required time lock.
+    // The BIP states that we should also do this if m_tx_modifiable's bit 2 is set
+    // (Has SIGHASH_SINGLE flag) but since we are only adding inputs at the end of the vector,
+    // we don't care about that.
+    bool iterate_inputs = psbtin.time_locktime != std::nullopt || psbtin.height_locktime != std::nullopt;
+    if (iterate_inputs) {
+        uint32_t old_timelock;
+        if (!ComputeTimeLock(old_timelock)) {
+            return false;
+        }
+
+        std::optional<uint32_t> time_lock = psbtin.time_locktime;
+        std::optional<uint32_t> height_lock = psbtin.height_locktime;
+        bool has_sigs = false;
+        for (const PSBTInput& input : inputs) {
+            if (input.time_locktime != std::nullopt && input.height_locktime == std::nullopt) {
+                height_lock.reset(); // Transaction can no longer have a height locktime
+                if (time_lock == std::nullopt) {
+                    return false;
+                }
+            } else if (input.time_locktime == std::nullopt && input.height_locktime != std::nullopt) {
+                time_lock.reset(); // Transaction can no longer have a time locktime
+                if (height_lock == std::nullopt) {
+                    return false;
+                }
+            }
+            if (input.time_locktime && time_lock != std::nullopt) {
+                time_lock = std::max(time_lock, input.time_locktime);
+            }
+            if (input.height_locktime && height_lock != std::nullopt) {
+                height_lock = std::max(height_lock, input.height_locktime);
+            }
+            if (!input.partial_sigs.empty()) {
+                has_sigs = true;
+            }
+        }
+        uint32_t new_timelock = fallback_locktime.value_or(0);
+        if (height_lock != std::nullopt && *height_lock > 0) {
+            new_timelock = *height_lock;
+        } else if (time_lock != std::nullopt && *time_lock > 0) {
+            new_timelock = *time_lock;
+        }
+        if (has_sigs && old_timelock != new_timelock) {
+            return false;
+        }
+    }
+
+    // Add the input to the end
+    inputs.push_back(psbtin);
+    return true;
 }
 
 bool PartiallySignedTransaction::AddOutput(const PSBTOutput& psbtout)
 {
+    if (psbtout.amount == std::nullopt || !psbtout.script.has_value()) {
+        return false;
+    }
+
     if (tx != std::nullopt) {
         // This is a v0 psbt, do the v0 AddOutput
         CTxOut txout(*psbtout.amount, *psbtout.script);
@@ -166,8 +228,14 @@ bool PartiallySignedTransaction::AddOutput(const PSBTOutput& psbtout)
         return true;
     }
 
-    // TOOD: Do PSBTv2
-    return false;
+    // No global tx, must be PSBTv2
+    // Check outputs are modifiable
+    if (m_tx_modifiable == std::nullopt || !m_tx_modifiable->test(1)) {
+        return false;
+    }
+    outputs.push_back(psbtout);
+
+    return true;
 }
 
 bool PSBTInput::GetUTXO(CTxOut& utxo) const
-- 
2.36.1


From e97320e4113be515b88bb2db2aac798235686b32 Mon Sep 17 00:00:00 2001
From: Andrew Chow <achow101-github@achow101.com>
Date: Mon, 18 Jan 2021 16:31:18 -0500
Subject: [PATCH 42/48] Implement PSBTv2 in decodepsbt

---
 src/rpc/rawtransaction.cpp  | 68 +++++++++++++++++++++++++++++++++++--
 test/functional/rpc_psbt.py |  2 +-
 2 files changed, 67 insertions(+), 3 deletions(-)

diff --git a/src/rpc/rawtransaction.cpp b/src/rpc/rawtransaction.cpp
index 3150426159..9f07a78610 100644
--- a/src/rpc/rawtransaction.cpp
+++ b/src/rpc/rawtransaction.cpp
@@ -691,7 +691,7 @@ static RPCHelpMan decodepsbt()
                 RPCResult{
                     RPCResult::Type::OBJ, "", "",
                     {
-                        {RPCResult::Type::OBJ, "tx", "The decoded network-serialized unsigned transaction.",
+                        {RPCResult::Type::OBJ, "tx", /*optional=*/true, "The decoded network-serialized unsigned transaction.",
                         {
                             {RPCResult::Type::ELISION, "", "The layout is the same as the output of decoderawtransaction."},
                         }},
@@ -704,7 +704,14 @@ static RPCHelpMan decodepsbt()
                                 {RPCResult::Type::STR, "path", "The path"},
                             }},
                         }},
-                        {RPCResult::Type::NUM, "psbt_version", "The PSBT version number. Not to be confused with the unsigned transaction version"},
+                        {RPCResult::Type::NUM, "tx_version", /* optional */ true, "The version number of the unsigned transaction. Not to be confused with PSBT version"},
+                        {RPCResult::Type::NUM, "fallback_locktime", /* optional */ true, "The locktime to fallback to if no inputs specify a required locktime."},
+                        {RPCResult::Type::NUM, "input_count", /* optional */ true, "The number of inputs in this psbt"},
+                        {RPCResult::Type::NUM, "output_count", /* optional */ true, "The number of outputs in this psbt."},
+                        {RPCResult::Type::BOOL, "inputs_modifiable", /* optional */ true, "Whether inputs can be modified"},
+                        {RPCResult::Type::BOOL, "outputs_modifiable", /* optional */ true, "Whether outputs can be modified"},
+                        {RPCResult::Type::BOOL, "has_sighash_single", /* optional */ true, "Whether this PSBT has SIGHASH_SINGLE inputs"},
+                        {RPCResult::Type::NUM, "psbt_version", /* optional */ true, "The PSBT version number. Not to be confused with the unsigned transaction version"},
                         {RPCResult::Type::ARR, "proprietary", "The global proprietary map",
                         {
                             {RPCResult::Type::OBJ, "", "",
@@ -827,6 +834,11 @@ static RPCHelpMan decodepsbt()
                                 }},
                                 {RPCResult::Type::STR_HEX, "taproot_internal_key", /*optional=*/ true, "The hex-encoded Taproot x-only internal key"},
                                 {RPCResult::Type::STR_HEX, "taproot_merkle_root", /*optional=*/ true, "The hex-encoded Taproot merkle root"},
+                                {RPCResult::Type::STR_HEX, "previous_txid", /*optional=*/ true, "TXID of the transaction containing the output being spent by this input."},
+                                {RPCResult::Type::NUM, "previous_vout", /* optional=*/ true, "Index of the output being spent"},
+                                {RPCResult::Type::NUM, "sequence", /* optional=*/ true, "Sequence number for this inputs"},
+                                {RPCResult::Type::NUM, "time_locktime", /* optional=*/ true, "Required time-based locktime for this input"},
+                                {RPCResult::Type::NUM, "height_locktime", /* optional=*/ true, "Required height-based locktime for this input"},
                                 {RPCResult::Type::OBJ_DYN, "unknown", /*optional=*/ true, "The unknown input fields",
                                 {
                                     {RPCResult::Type::STR_HEX, "key", "(key-value pair) An unknown key-value pair"},
@@ -891,6 +903,10 @@ static RPCHelpMan decodepsbt()
                                         }},
                                     }},
                                 }},
+                                {RPCResult::Type::NUM, "amount", /* optional=*/ true, "The amount (nValue) for this output"},
+                                {RPCResult::Type::OBJ, "script", /* optional=*/ true, "The output script (scriptPubKey) for this output",
+                                    {{RPCResult::Type::ELISION, "", "The layout is the same as the output of scriptPubKeys in decoderawtransaction."}},
+                                },
                                 {RPCResult::Type::OBJ_DYN, "unknown", /*optional=*/true, "The unknown output fields",
                                 {
                                     {RPCResult::Type::STR_HEX, "key", "(key-value pair) An unknown key-value pair"},
@@ -950,6 +966,23 @@ static RPCHelpMan decodepsbt()
     }
     result.pushKV("global_xpubs", global_xpubs);
 
+    // Add PSBTv2 stuff
+    if (psbtx.GetVersion() == 2) {
+        if (psbtx.tx_version != std::nullopt) {
+            result.pushKV("tx_version", *psbtx.tx_version);
+        }
+        if (psbtx.fallback_locktime != std::nullopt) {
+            result.pushKV("fallback_locktime", static_cast<uint64_t>(*psbtx.fallback_locktime));
+        }
+        result.pushKV("input_count", (uint64_t)psbtx.inputs.size());
+        result.pushKV("output_count", (uint64_t)psbtx.outputs.size());
+        if (psbtx.m_tx_modifiable != std::nullopt) {
+            result.pushKV("inputs_modifiable", psbtx.m_tx_modifiable->test(0));
+            result.pushKV("outputs_modifiable", psbtx.m_tx_modifiable->test(1));
+            result.pushKV("has_sighash_single", psbtx.m_tx_modifiable->test(2));
+        }
+    }
+
     // PSBT version
     result.pushKV("psbt_version", static_cast<uint64_t>(psbtx.GetVersion()));
 
@@ -1173,6 +1206,25 @@ static RPCHelpMan decodepsbt()
             in.pushKV("taproot_merkle_root", HexStr(input.m_tap_merkle_root));
         }
 
+        // PSBTv2
+        if (psbtx.GetVersion() == 2) {
+            if (!input.prev_txid.IsNull()) {
+                in.pushKV("previous_txid", input.prev_txid.GetHex());
+            }
+            if (input.prev_out != std::nullopt) {
+                in.pushKV("previous_vout", static_cast<uint64_t>(*input.prev_out));
+            }
+            if (input.sequence != std::nullopt) {
+                in.pushKV("sequence", static_cast<uint64_t>(*input.sequence));
+            }
+            if (input.time_locktime != std::nullopt) {
+                in.pushKV("time_locktime", static_cast<uint64_t>(*input.time_locktime));
+            }
+            if (input.height_locktime!= std::nullopt) {
+                in.pushKV("height_locktime", static_cast<uint64_t>(*input.height_locktime));
+            }
+        }
+
         // Proprietary
         if (!input.m_proprietary.empty()) {
             UniValue proprietary(UniValue::VARR);
@@ -1272,6 +1324,18 @@ static RPCHelpMan decodepsbt()
             out.pushKV("taproot_bip32_derivs", keypaths);
         }
 
+        // PSBTv2 stuff
+        if (psbtx.GetVersion() == 2) {
+            if (output.amount != std::nullopt) {
+                out.pushKV("amount", ValueFromAmount(*output.amount));
+            }
+            if (output.script.has_value()) {
+                UniValue spk(UniValue::VOBJ);
+                ScriptToUniv(*output.script, spk, /*include_hex=*/true, /*include_address=*/true);
+                out.pushKV("script", spk);
+            }
+        }
+
         // Proprietary
         if (!output.m_proprietary.empty()) {
             UniValue proprietary(UniValue::VARR);
diff --git a/test/functional/rpc_psbt.py b/test/functional/rpc_psbt.py
index d00135c835..e905d40921 100755
--- a/test/functional/rpc_psbt.py
+++ b/test/functional/rpc_psbt.py
@@ -104,7 +104,7 @@ class PSBTTest(BitcoinTestFramework):
         assert_raises_rpc_error(-4, "Insufficient funds", self.nodes[0].walletcreatefundedpsbt, [{"txid": utxo1['txid'], "vout": utxo1['vout']}], {self.nodes[2].getnewaddress():90})
 
         psbtx1 = self.nodes[0].walletcreatefundedpsbt([{"txid": utxo1['txid'], "vout": utxo1['vout']}], {self.nodes[2].getnewaddress():90}, 0, {"add_inputs": True})['psbt']
-        assert_equal(len(self.nodes[0].decodepsbt(psbtx1)['tx']['vin']), 2)
+        assert_equal(len(self.nodes[0].decodepsbt(psbtx1)['inputs']), 2)
 
         # Inputs argument can be null
         self.nodes[0].walletcreatefundedpsbt(None, {self.nodes[2].getnewaddress():10})
-- 
2.36.1


From 7ac7be46168a7b2e43b08d5d2d12948472af9604 Mon Sep 17 00:00:00 2001
From: Andrew Chow <achow101-github@achow101.com>
Date: Mon, 18 Jan 2021 16:55:20 -0500
Subject: [PATCH 43/48] Allow specifying PSBT version in constructor

---
 src/psbt.cpp | 7 +++++--
 src/psbt.h   | 2 +-
 2 files changed, 6 insertions(+), 3 deletions(-)

diff --git a/src/psbt.cpp b/src/psbt.cpp
index 67d9c608f6..2e83f6da55 100644
--- a/src/psbt.cpp
+++ b/src/psbt.cpp
@@ -9,11 +9,14 @@
 #include <util/strencodings.h>
 
 
-PartiallySignedTransaction::PartiallySignedTransaction(const CMutableTransaction& tx) : tx(tx)
+PartiallySignedTransaction::PartiallySignedTransaction(const CMutableTransaction& tx, uint32_t version) : m_version(version)
 {
+    if (version == 0) {
+        this->tx = tx;
+    }
     inputs.resize(tx.vin.size(), PSBTInput(GetVersion()));
     outputs.resize(tx.vout.size(), PSBTOutput(GetVersion()));
-    CacheUnsignedTxPieces();
+    SetupFromTx(tx);
 }
 
 bool PartiallySignedTransaction::IsNull() const
diff --git a/src/psbt.h b/src/psbt.h
index 9165bcf4a5..5fd9d74426 100644
--- a/src/psbt.h
+++ b/src/psbt.h
@@ -1138,7 +1138,7 @@ struct PartiallySignedTransaction
     CMutableTransaction GetUnsignedTx() const;
     uint256 GetUniqueID() const;
     PartiallySignedTransaction() {}
-    explicit PartiallySignedTransaction(const CMutableTransaction& tx);
+    explicit PartiallySignedTransaction(const CMutableTransaction& tx, uint32_t version = 0);
 
     template <typename Stream>
     inline void Serialize(Stream& s) const {
-- 
2.36.1


From 3dbd5da1535e278d1b86af1c4842c943927f0623 Mon Sep 17 00:00:00 2001
From: Andrew Chow <achow101-github@achow101.com>
Date: Mon, 18 Jan 2021 17:12:48 -0500
Subject: [PATCH 44/48] Update PSBT::UpdatePSBTOutput to use GetUnsignedTx

---
 src/psbt.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/psbt.cpp b/src/psbt.cpp
index 2e83f6da55..cbd2d12135 100644
--- a/src/psbt.cpp
+++ b/src/psbt.cpp
@@ -475,7 +475,7 @@ size_t CountPSBTUnsignedInputs(const PartiallySignedTransaction& psbt) {
 
 void UpdatePSBTOutput(const SigningProvider& provider, PartiallySignedTransaction& psbt, int index)
 {
-    CMutableTransaction& tx = *Assert(psbt.tx);
+    CMutableTransaction tx = psbt.GetUnsignedTx();
     const CTxOut& out = tx.vout.at(index);
     PSBTOutput& psbt_out = psbt.outputs.at(index);
 
-- 
2.36.1


From e4c3d282693df65896f7c70022f6935ec4d23fa8 Mon Sep 17 00:00:00 2001
From: Andrew Chow <achow101-github@achow101.com>
Date: Mon, 25 Jan 2021 16:11:50 -0500
Subject: [PATCH 45/48] Restrict joinpsbts to PSBTv0 only

---
 src/rpc/rawtransaction.cpp | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/src/rpc/rawtransaction.cpp b/src/rpc/rawtransaction.cpp
index 9f07a78610..79f7fd257b 100644
--- a/src/rpc/rawtransaction.cpp
+++ b/src/rpc/rawtransaction.cpp
@@ -1736,6 +1736,9 @@ static RPCHelpMan joinpsbts()
         if (!DecodeBase64PSBT(psbtx, txs[i].get_str(), error)) {
             throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf("TX decode failed %s", error));
         }
+        if (psbtx.GetVersion() != 0) {
+            throw JSONRPCError(RPC_INVALID_PARAMETER, "joinpsbts only operates on version 0 PSBTs");
+        }
         psbtxs.push_back(psbtx);
         // Choose the highest version number
         if (*psbtx.tx_version > best_version) {
-- 
2.36.1


From eb7d6bb1d110c800db3f3f78ffd75af8c01bc033 Mon Sep 17 00:00:00 2001
From: Andrew Chow <achow101-github@achow101.com>
Date: Mon, 18 Jan 2021 17:13:27 -0500
Subject: [PATCH 46/48] Allow createpsbt and walletcreatefundedpsbt to take
 psbt version

Use v2 for other RPCs. For some tests to work, PSBTv0 is set explicitly.
---
 src/psbt.h                                    |  2 +-
 src/rpc/client.cpp                            |  2 +
 src/rpc/rawtransaction.cpp                    | 30 +++----
 src/wallet/rpc/spend.cpp                      | 18 ++++-
 test/functional/data/rpc_psbt.json            |  1 +
 test/functional/rpc_psbt.py                   | 79 +++++++++++--------
 test/functional/wallet_bumpfee.py             |  4 +-
 .../wallet_multisig_descriptor_psbt.py        |  8 +-
 test/functional/wallet_send.py                | 10 +--
 9 files changed, 88 insertions(+), 66 deletions(-)

diff --git a/src/psbt.h b/src/psbt.h
index 5fd9d74426..6ddd8d6235 100644
--- a/src/psbt.h
+++ b/src/psbt.h
@@ -81,7 +81,7 @@ static constexpr uint8_t PSBT_SEPARATOR = 0x00;
 const std::streamsize MAX_FILE_SIZE_PSBT = 100000000; // 100 MiB
 
 // PSBT version number
-static constexpr uint32_t PSBT_HIGHEST_VERSION = 0;
+static constexpr uint32_t PSBT_HIGHEST_VERSION = 2;
 
 /** A structure for PSBT proprietary types */
 struct PSBTProprietary
diff --git a/src/rpc/client.cpp b/src/rpc/client.cpp
index 23e9d4074c..ba59e376c3 100644
--- a/src/rpc/client.cpp
+++ b/src/rpc/client.cpp
@@ -118,6 +118,7 @@ static const CRPCConvertParam vRPCConvertParams[] =
     { "walletcreatefundedpsbt", 2, "locktime" },
     { "walletcreatefundedpsbt", 3, "options" },
     { "walletcreatefundedpsbt", 4, "bip32derivs" },
+    { "walletcreatefundedpsbt", 5, "psbt_version" },
     { "walletprocesspsbt", 1, "sign" },
     { "walletprocesspsbt", 3, "bip32derivs" },
     { "walletprocesspsbt", 4, "finalize" },
@@ -125,6 +126,7 @@ static const CRPCConvertParam vRPCConvertParams[] =
     { "createpsbt", 1, "outputs" },
     { "createpsbt", 2, "locktime" },
     { "createpsbt", 3, "replaceable" },
+    { "createpsbt", 4, "psbt_version" },
     { "combinepsbt", 0, "txs"},
     { "joinpsbts", 0, "txs"},
     { "finalizepsbt", 1, "extract"},
diff --git a/src/rpc/rawtransaction.cpp b/src/rpc/rawtransaction.cpp
index 79f7fd257b..ab53aed499 100644
--- a/src/rpc/rawtransaction.cpp
+++ b/src/rpc/rawtransaction.cpp
@@ -1493,7 +1493,12 @@ static RPCHelpMan createpsbt()
     return RPCHelpMan{"createpsbt",
                 "\nCreates a transaction in the Partially Signed Transaction format.\n"
                 "Implements the Creator role.\n",
-                CreateTxDoc(),
+                Cat<std::vector<RPCArg>>(
+                    CreateTxDoc(),
+                    {
+                        {"psbt_version", RPCArg::Type::NUM, RPCArg::Default{2}, "The PSBT version number to use."},
+                    }
+                ),
                 RPCResult{
                     RPCResult::Type::STR, "", "The resulting raw transaction (base64-encoded string)"
                 },
@@ -1508,6 +1513,7 @@ static RPCHelpMan createpsbt()
         UniValueType(), // ARR or OBJ, checked later
         UniValue::VNUM,
         UniValue::VBOOL,
+        UniValue::VNUM,
         }, true
     );
 
@@ -1518,15 +1524,16 @@ static RPCHelpMan createpsbt()
     CMutableTransaction rawTx = ConstructTransaction(request.params[0], request.params[1], request.params[2], rbf);
 
     // Make a blank psbt
-    PartiallySignedTransaction psbtx;
-    psbtx.tx = rawTx;
-    for (unsigned int i = 0; i < rawTx.vin.size(); ++i) {
-        psbtx.inputs.push_back(PSBTInput(0));
+    uint32_t psbt_version = 2;
+    if (!request.params[4].isNull()) {
+        psbt_version = request.params[4].get_int();
     }
-    for (unsigned int i = 0; i < rawTx.vout.size(); ++i) {
-        psbtx.outputs.push_back(PSBTOutput(0));
+    if (psbt_version != 2 && psbt_version != 0) {
+        throw JSONRPCError(RPC_INVALID_PARAMETER, "The PSBT version can only be 2 or 0");
     }
 
+    PartiallySignedTransaction psbtx(rawTx, psbt_version);
+
     // Serialize the PSBT
     CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);
     ssTx << psbtx;
@@ -1587,14 +1594,7 @@ static RPCHelpMan converttopsbt()
     }
 
     // Make a blank psbt
-    PartiallySignedTransaction psbtx;
-    psbtx.tx = tx;
-    for (unsigned int i = 0; i < tx.vin.size(); ++i) {
-        psbtx.inputs.push_back(PSBTInput(0));
-    }
-    for (unsigned int i = 0; i < tx.vout.size(); ++i) {
-        psbtx.outputs.push_back(PSBTOutput(0));
-    }
+    PartiallySignedTransaction psbtx(tx, 2 /* version */);
 
     // Serialize the PSBT
     CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);
diff --git a/src/wallet/rpc/spend.cpp b/src/wallet/rpc/spend.cpp
index c7b57ba4be..cc3d304ea1 100644
--- a/src/wallet/rpc/spend.cpp
+++ b/src/wallet/rpc/spend.cpp
@@ -79,7 +79,7 @@ static void InterpretFeeEstimationInstructions(const UniValue& conf_target, cons
 static UniValue FinishTransaction(const std::shared_ptr<CWallet> pwallet, const UniValue& options, const CMutableTransaction& rawTx)
 {
     // Make a blank psbt
-    PartiallySignedTransaction psbtx(rawTx);
+    PartiallySignedTransaction psbtx(rawTx, /*version=*/2);
 
     // First fill transaction with our data without signing,
     // so external signers are not asked sign more than once.
@@ -1097,7 +1097,7 @@ static RPCHelpMan bumpfee_helper(std::string method_name)
 
         result.pushKV("txid", txid.GetHex());
     } else {
-        PartiallySignedTransaction psbtx(mtx);
+        PartiallySignedTransaction psbtx(mtx, /* version=*/ 2);
         bool complete = false;
         const TransactionError err = pwallet->FillPSBT(psbtx, complete, SIGHASH_DEFAULT, false /* sign */, true /* bip32derivs */);
         CHECK_NONFATAL(err == TransactionError::OK);
@@ -1618,6 +1618,7 @@ RPCHelpMan walletcreatefundedpsbt()
                         FundTxDoc()),
                         "options"},
                     {"bip32derivs", RPCArg::Type::BOOL, RPCArg::Default{true}, "Include BIP 32 derivation paths for public keys if we know them"},
+                    {"psbt_version", RPCArg::Type::NUM, RPCArg::Default(2), "The PSBT version number to use."},
                 },
                 RPCResult{
                     RPCResult::Type::OBJ, "", "",
@@ -1646,7 +1647,8 @@ RPCHelpMan walletcreatefundedpsbt()
         UniValueType(), // ARR or OBJ, checked later
         UniValue::VNUM,
         UniValue::VOBJ,
-        UniValue::VBOOL
+        UniValue::VBOOL,
+        UniValue::VNUM
         }, true
     );
 
@@ -1669,7 +1671,15 @@ RPCHelpMan walletcreatefundedpsbt()
     FundTransaction(wallet, rawTx, fee, change_position, options, coin_control, /*override_min_fee=*/true);
 
     // Make a blank psbt
-    PartiallySignedTransaction psbtx(rawTx);
+    uint32_t psbt_version = 2;
+    if (!request.params[5].isNull()) {
+        psbt_version = request.params[5].get_int();
+    }
+    if (psbt_version != 2 && psbt_version != 0) {
+        throw JSONRPCError(RPC_INVALID_PARAMETER, "The PSBT version can only be 2 or 0");
+    }
+
+    PartiallySignedTransaction psbtx(rawTx, /* version=*/ 2);
 
     // Fill transaction with out data but don't sign
     bool bip32derivs = request.params[4].isNull() ? true : request.params[4].get_bool();
diff --git a/test/functional/data/rpc_psbt.json b/test/functional/data/rpc_psbt.json
index 19b62b6125..cd82cf1f0b 100644
--- a/test/functional/data/rpc_psbt.json
+++ b/test/functional/data/rpc_psbt.json
@@ -82,6 +82,7 @@
                     "bcrt1qqzh2ngh97ru8dfvgma25d6r595wcwqy0cee4cc": 1
                 }
             ],
+            "version": 0,
             "result" : "cHNidP8BAJoCAAAAAljoeiG1ba8MI76OcHBFbDNvfLqlyHV5JPVFiHuyq911AAAAAAD/////g40EJ9DsZQpoqka7CwmK6kQiwHGyyng1Kgd5WdB86h0BAAAAAP////8CcKrwCAAAAAAWABTYXCtx0AYLCcmIauuBXlCZHdoSTQDh9QUAAAAAFgAUAK6pouXw+HaliN9VRuh0LR2HAI8AAAAAAAAAAAA="
         }
     ],
diff --git a/test/functional/rpc_psbt.py b/test/functional/rpc_psbt.py
index e905d40921..a0f58673e9 100755
--- a/test/functional/rpc_psbt.py
+++ b/test/functional/rpc_psbt.py
@@ -93,7 +93,7 @@ class PSBTTest(BitcoinTestFramework):
         # The decodepsbt RPC is stateless and independent of any settings, we can always just call it on the first node
         decoded_psbt = self.nodes[0].decodepsbt(psbtx["psbt"])
         changepos = psbtx["changepos"]
-        assert_equal(decoded_psbt["tx"]["vout"][changepos]["scriptPubKey"]["type"], expected_type)
+        assert_equal(decoded_psbt["outputs"][changepos]["script"]["type"], expected_type)
 
     def run_test(self):
         # Create and fund a raw tx for sending 10 BTC
@@ -333,12 +333,14 @@ class PSBTTest(BitcoinTestFramework):
         # Update psbts, should only have data for one input and not the other
         psbt1 = self.nodes[1].walletprocesspsbt(psbt_orig, False, "ALL")['psbt']
         psbt1_decoded = self.nodes[0].decodepsbt(psbt1)
-        assert psbt1_decoded['inputs'][0] and not psbt1_decoded['inputs'][1]
+        assert len(psbt1_decoded['inputs'][0].keys()) > 3
+        assert len(psbt1_decoded['inputs'][1].keys()) == 3
         # Check that BIP32 path was added
         assert "bip32_derivs" in psbt1_decoded['inputs'][0]
         psbt2 = self.nodes[2].walletprocesspsbt(psbt_orig, False, "ALL", False)['psbt']
         psbt2_decoded = self.nodes[0].decodepsbt(psbt2)
-        assert not psbt2_decoded['inputs'][0] and psbt2_decoded['inputs'][1]
+        assert len(psbt2_decoded['inputs'][0].keys()) == 3
+        assert len(psbt2_decoded['inputs'][1].keys()) > 3
         # Check that BIP32 paths were not added
         assert "bip32_derivs" not in psbt2_decoded['inputs'][1]
 
@@ -360,33 +362,33 @@ class PSBTTest(BitcoinTestFramework):
         unspent = self.nodes[0].listunspent()[0]
         psbtx_info = self.nodes[0].walletcreatefundedpsbt([{"txid":unspent["txid"], "vout":unspent["vout"]}], [{self.nodes[2].getnewaddress():unspent["amount"]+1}], block_height+2, {"replaceable": False, "add_inputs": True}, False)
         decoded_psbt = self.nodes[0].decodepsbt(psbtx_info["psbt"])
-        for tx_in, psbt_in in zip(decoded_psbt["tx"]["vin"], decoded_psbt["inputs"]):
-            assert_greater_than(tx_in["sequence"], MAX_BIP125_RBF_SEQUENCE)
+        for psbt_in in decoded_psbt["inputs"]:
+            assert_greater_than(psbt_in["sequence"], MAX_BIP125_RBF_SEQUENCE)
             assert "bip32_derivs" not in psbt_in
-        assert_equal(decoded_psbt["tx"]["locktime"], block_height+2)
+        assert_equal(decoded_psbt["fallback_locktime"], block_height+2)
 
         # Same construction with only locktime set and RBF explicitly enabled
         psbtx_info = self.nodes[0].walletcreatefundedpsbt([{"txid":unspent["txid"], "vout":unspent["vout"]}], [{self.nodes[2].getnewaddress():unspent["amount"]+1}], block_height, {"replaceable": True, "add_inputs": True}, True)
         decoded_psbt = self.nodes[0].decodepsbt(psbtx_info["psbt"])
-        for tx_in, psbt_in in zip(decoded_psbt["tx"]["vin"], decoded_psbt["inputs"]):
-            assert_equal(tx_in["sequence"], MAX_BIP125_RBF_SEQUENCE)
+        for psbt_in in decoded_psbt["inputs"]:
+            assert_equal(psbt_in["sequence"], MAX_BIP125_RBF_SEQUENCE)
             assert "bip32_derivs" in psbt_in
-        assert_equal(decoded_psbt["tx"]["locktime"], block_height)
+        assert_equal(decoded_psbt["fallback_locktime"], block_height)
 
         # Same construction without optional arguments
         psbtx_info = self.nodes[0].walletcreatefundedpsbt([], [{self.nodes[2].getnewaddress():unspent["amount"]+1}])
         decoded_psbt = self.nodes[0].decodepsbt(psbtx_info["psbt"])
-        for tx_in, psbt_in in zip(decoded_psbt["tx"]["vin"], decoded_psbt["inputs"]):
-            assert_equal(tx_in["sequence"], MAX_BIP125_RBF_SEQUENCE)
+        for psbt_in in decoded_psbt["inputs"]:
+            assert_equal(psbt_in["sequence"], MAX_BIP125_RBF_SEQUENCE)
             assert "bip32_derivs" in psbt_in
-        assert_equal(decoded_psbt["tx"]["locktime"], 0)
+        assert_equal(decoded_psbt["fallback_locktime"], 0)
 
         # Same construction without optional arguments, for a node with -walletrbf=0
         unspent1 = self.nodes[1].listunspent()[0]
         psbtx_info = self.nodes[1].walletcreatefundedpsbt([{"txid":unspent1["txid"], "vout":unspent1["vout"]}], [{self.nodes[2].getnewaddress():unspent1["amount"]+1}], block_height, {"add_inputs": True})
         decoded_psbt = self.nodes[1].decodepsbt(psbtx_info["psbt"])
-        for tx_in, psbt_in in zip(decoded_psbt["tx"]["vin"], decoded_psbt["inputs"]):
-            assert_greater_than(tx_in["sequence"], MAX_BIP125_RBF_SEQUENCE)
+        for psbt_in in decoded_psbt["inputs"]:
+            assert_greater_than(psbt_in["sequence"], MAX_BIP125_RBF_SEQUENCE)
             assert "bip32_derivs" in psbt_in
 
         # Make sure change address wallet does not have P2SH innerscript access to results in success
@@ -452,7 +454,7 @@ class PSBTTest(BitcoinTestFramework):
 
         # Creator Tests
         for creator in creators:
-            created_tx = self.nodes[0].createpsbt(creator['inputs'], creator['outputs'])
+            created_tx = self.nodes[0].createpsbt(inputs=creator['inputs'], outputs=creator['outputs'], psbt_version=creator['version'])
             assert_equal(created_tx, creator['result'])
 
         # Signer tests
@@ -509,6 +511,8 @@ class PSBTTest(BitcoinTestFramework):
         vout3 = find_output(self.nodes[0], txid3, 11)
         self.sync_all()
 
+        psbt_v2_required_keys = ["previous_vout", "sequence", "previous_txid"]
+
         def test_psbt_input_keys(psbt_input, keys):
             """Check that the psbt input has only the expected keys."""
             assert_equal(set(keys), set(psbt_input.keys()))
@@ -516,48 +520,57 @@ class PSBTTest(BitcoinTestFramework):
         # Create a PSBT. None of the inputs are filled initially
         psbt = self.nodes[1].createpsbt([{"txid":txid1, "vout":vout1},{"txid":txid2, "vout":vout2},{"txid":txid3, "vout":vout3}], {self.nodes[0].getnewaddress():32.999})
         decoded = self.nodes[1].decodepsbt(psbt)
-        test_psbt_input_keys(decoded['inputs'][0], [])
-        test_psbt_input_keys(decoded['inputs'][1], [])
-        test_psbt_input_keys(decoded['inputs'][2], [])
+        test_psbt_input_keys(decoded['inputs'][0], psbt_v2_required_keys)
+        test_psbt_input_keys(decoded['inputs'][1], psbt_v2_required_keys)
+        test_psbt_input_keys(decoded['inputs'][2], psbt_v2_required_keys)
 
         # Update a PSBT with UTXOs from the node
         # Bech32 inputs should be filled with witness UTXO. Other inputs should not be filled because they are non-witness
         updated = self.nodes[1].utxoupdatepsbt(psbt)
         decoded = self.nodes[1].decodepsbt(updated)
-        test_psbt_input_keys(decoded['inputs'][0], ['witness_utxo'])
-        test_psbt_input_keys(decoded['inputs'][1], [])
-        test_psbt_input_keys(decoded['inputs'][2], [])
+        test_psbt_input_keys(decoded['inputs'][0], psbt_v2_required_keys + ['witness_utxo'])
+        test_psbt_input_keys(decoded['inputs'][1], psbt_v2_required_keys)
+        test_psbt_input_keys(decoded['inputs'][2], psbt_v2_required_keys)
 
         # Try again, now while providing descriptors, making P2SH-segwit work, and causing bip32_derivs and redeem_script to be filled in
         descs = [self.nodes[1].getaddressinfo(addr)['desc'] for addr in [addr1,addr2,addr3]]
         updated = self.nodes[1].utxoupdatepsbt(psbt=psbt, descriptors=descs)
         decoded = self.nodes[1].decodepsbt(updated)
-        test_psbt_input_keys(decoded['inputs'][0], ['witness_utxo', 'bip32_derivs'])
-        test_psbt_input_keys(decoded['inputs'][1], [])
-        test_psbt_input_keys(decoded['inputs'][2], ['witness_utxo', 'bip32_derivs', 'redeem_script'])
+        test_psbt_input_keys(decoded['inputs'][0], psbt_v2_required_keys + ['witness_utxo', 'bip32_derivs'])
+        test_psbt_input_keys(decoded['inputs'][1], psbt_v2_required_keys)
+        test_psbt_input_keys(decoded['inputs'][2], psbt_v2_required_keys + ['witness_utxo', 'bip32_derivs', 'redeem_script'])
+
+        # Cannot join PSBTv2s
+        psbt1 = self.nodes[1].createpsbt(inputs=[{"txid":txid1, "vout":vout1}], outputs={self.nodes[0].getnewaddress():Decimal('10.999')}, psbt_version=0)
+        psbt2 = self.nodes[1].createpsbt(inputs=[{"txid":txid1, "vout":vout1}], outputs={self.nodes[0].getnewaddress():Decimal('10.999')}, psbt_version=2)
+        assert_raises_rpc_error(-8, "joinpsbts only operates on version 0 PSBTs", self.nodes[1].joinpsbts, [psbt1, psbt2])
 
         # Two PSBTs with a common input should not be joinable
-        psbt1 = self.nodes[1].createpsbt([{"txid":txid1, "vout":vout1}], {self.nodes[0].getnewaddress():Decimal('10.999')})
-        assert_raises_rpc_error(-8, "exists in multiple PSBTs", self.nodes[1].joinpsbts, [psbt1, updated])
+        psbt2 = self.nodes[1].createpsbt(inputs=[{"txid":txid1, "vout":vout1}], outputs={self.nodes[0].getnewaddress():Decimal('10.999')}, psbt_version=0)
+        assert_raises_rpc_error(-8, "exists in multiple PSBTs", self.nodes[1].joinpsbts, [psbt1, psbt2])
 
         # Join two distinct PSBTs
+        psbt1 = self.nodes[1].createpsbt(inputs=[{"txid":txid1, "vout":vout1},{"txid":txid2, "vout":vout2},{"txid":txid3, "vout":vout3}], outputs={self.nodes[0].getnewaddress():32.999}, psbt_version=0)
         addr4 = self.nodes[1].getnewaddress("", "p2sh-segwit")
         txid4 = self.nodes[0].sendtoaddress(addr4, 5)
         vout4 = find_output(self.nodes[0], txid4, 5)
         self.generate(self.nodes[0], 6)
-        psbt2 = self.nodes[1].createpsbt([{"txid":txid4, "vout":vout4}], {self.nodes[0].getnewaddress():Decimal('4.999')})
+        psbt2 = self.nodes[1].createpsbt(inputs=[{"txid":txid4, "vout":vout4}], outputs={self.nodes[0].getnewaddress():Decimal('4.999')}, psbt_version=0)
         psbt2 = self.nodes[1].walletprocesspsbt(psbt2)['psbt']
         psbt2_decoded = self.nodes[0].decodepsbt(psbt2)
         assert "final_scriptwitness" in psbt2_decoded['inputs'][0] and "final_scriptSig" in psbt2_decoded['inputs'][0]
-        joined = self.nodes[0].joinpsbts([psbt, psbt2])
+        joined = self.nodes[0].joinpsbts([psbt1, psbt2])
         joined_decoded = self.nodes[0].decodepsbt(joined)
-        assert len(joined_decoded['inputs']) == 4 and len(joined_decoded['outputs']) == 2 and "final_scriptwitness" not in joined_decoded['inputs'][3] and "final_scriptSig" not in joined_decoded['inputs'][3]
+        assert_equal(len(joined_decoded['inputs']), 4)
+        assert_equal(len(joined_decoded['outputs']), 2)
+        assert "final_scriptwitness" not in joined_decoded['inputs'][3]
+        assert "final_scriptSig" not in joined_decoded['inputs'][3]
 
         # Check that joining shuffles the inputs and outputs
         # 10 attempts should be enough to get a shuffled join
         shuffled = False
         for _ in range(10):
-            shuffled_joined = self.nodes[0].joinpsbts([psbt, psbt2])
+            shuffled_joined = self.nodes[0].joinpsbts([psbt1, psbt2])
             shuffled |= joined != shuffled_joined
             if shuffled:
                 break
@@ -653,11 +666,9 @@ class PSBTTest(BitcoinTestFramework):
         final = self.nodes[0].finalizepsbt(signed['psbt'], False)
 
         dec = self.nodes[0].decodepsbt(signed["psbt"])
-        for i, txin in enumerate(dec["tx"]["vin"]):
-            if txin["txid"] == ext_utxo["txid"] and txin["vout"] == ext_utxo["vout"]:
-                input_idx = i
+        for psbt_in in dec["inputs"]:
+            if psbt_in["previous_txid"] == ext_utxo["txid"] and psbt_in["previous_vout"] == ext_utxo["vout"]:
                 break
-        psbt_in = dec["inputs"][input_idx]
         # Calculate the input weight
         # (prevout + sequence + length of scriptSig + scriptsig + 1 byte buffer) * WITNESS_SCALE_FACTOR + num scriptWitness stack items + (length of stack item + stack item) * N stack items + 1 byte buffer
         len_scriptsig = len(psbt_in["final_scriptSig"]["hex"]) // 2 if "final_scriptSig" in psbt_in else 0
diff --git a/test/functional/wallet_bumpfee.py b/test/functional/wallet_bumpfee.py
index 3b23ee8e94..9cc60c2bc1 100755
--- a/test/functional/wallet_bumpfee.py
+++ b/test/functional/wallet_bumpfee.py
@@ -448,14 +448,14 @@ def test_watchonly_psbt(self, peer_node, rbf_node, dest_address):
     psbt_signed = signer.walletprocesspsbt(psbt=psbt, sign=True, sighashtype="ALL", bip32derivs=True)
     psbt_final = watcher.finalizepsbt(psbt_signed["psbt"])
     original_txid = watcher.sendrawtransaction(psbt_final["hex"])
-    assert_equal(len(watcher.decodepsbt(psbt)["tx"]["vin"]), 1)
+    assert_equal(len(watcher.decodepsbt(psbt)["inputs"]), 1)
 
     # bumpfee can't be used on watchonly wallets
     assert_raises_rpc_error(-4, "bumpfee is not available with wallets that have private keys disabled. Use psbtbumpfee instead.", watcher.bumpfee, original_txid)
 
     # Bump fee, obnoxiously high to add additional watchonly input
     bumped_psbt = watcher.psbtbumpfee(original_txid, {"fee_rate": HIGH})
-    assert_greater_than(len(watcher.decodepsbt(bumped_psbt['psbt'])["tx"]["vin"]), 1)
+    assert_greater_than(len(watcher.decodepsbt(bumped_psbt['psbt'])["inputs"]), 1)
     assert "txid" not in bumped_psbt
     assert_equal(bumped_psbt["origfee"], -watcher.gettransaction(original_txid)["fee"])
     assert not watcher.finalizepsbt(bumped_psbt["psbt"])["complete"]
diff --git a/test/functional/wallet_multisig_descriptor_psbt.py b/test/functional/wallet_multisig_descriptor_psbt.py
index 2b565db137..10c094e165 100755
--- a/test/functional/wallet_multisig_descriptor_psbt.py
+++ b/test/functional/wallet_multisig_descriptor_psbt.py
@@ -35,13 +35,13 @@ class WalletMultisigDescriptorPSBTTest(BitcoinTestFramework):
     @staticmethod
     def _check_psbt(psbt, to, value, multisig):
         """Helper function for any of the N participants to check the psbt with decodepsbt and verify it is OK before signing."""
-        tx = multisig.decodepsbt(psbt)["tx"]
+        decoded = multisig.decodepsbt(psbt)
         amount = 0
-        for vout in tx["vout"]:
-            address = vout["scriptPubKey"]["address"]
+        for psbt_out in decoded["outputs"]:
+            address = psbt_out["script"]["address"]
             assert_equal(multisig.getaddressinfo(address)["ischange"], address != to)
             if address == to:
-                amount += vout["value"]
+                amount += psbt_out["amount"]
         assert_approx(amount, float(value), vspan=0.001)
 
     def participants_create_multisigs(self, xpubs):
diff --git a/test/functional/wallet_send.py b/test/functional/wallet_send.py
index 07baa0595e..25c309ac36 100755
--- a/test/functional/wallet_send.py
+++ b/test/functional/wallet_send.py
@@ -424,10 +424,10 @@ class WalletSendTest(BitcoinTestFramework):
         assert res["complete"]
         res = self.test_send(from_wallet=w0, to_wallet=w1, amount=1, add_to_wallet=False, change_address=change_address, change_position=0)
         assert res["complete"]
-        assert_equal(self.nodes[0].decodepsbt(res["psbt"])["tx"]["vout"][0]["scriptPubKey"]["address"], change_address)
+        assert_equal(self.nodes[0].decodepsbt(res["psbt"])["outputs"][0]["script"]["address"], change_address)
         res = self.test_send(from_wallet=w0, to_wallet=w1, amount=1, add_to_wallet=False, change_type="legacy", change_position=0)
         assert res["complete"]
-        change_address = self.nodes[0].decodepsbt(res["psbt"])["tx"]["vout"][0]["scriptPubKey"]["address"]
+        change_address = self.nodes[0].decodepsbt(res["psbt"])["outputs"][0]["script"]["address"]
         assert change_address[0] == "m" or change_address[0] == "n"
 
         self.log.info("Set lock time...")
@@ -524,11 +524,9 @@ class WalletSendTest(BitcoinTestFramework):
         self.nodes[0].finalizepsbt(signed["psbt"])
 
         dec = self.nodes[0].decodepsbt(signed["psbt"])
-        for i, txin in enumerate(dec["tx"]["vin"]):
-            if txin["txid"] == ext_utxo["txid"] and txin["vout"] == ext_utxo["vout"]:
-                input_idx = i
+        for psbt_in in dec["inputs"]:
+            if psbt_in["previous_txid"] == ext_utxo["txid"] and psbt_in["previous_vout"] == ext_utxo["vout"]:
                 break
-        psbt_in = dec["inputs"][input_idx]
         # Calculate the input weight
         # (prevout + sequence + length of scriptSig + scriptsig + 1 byte buffer) * WITNESS_SCALE_FACTOR + num scriptWitness stack items + (length of stack item + stack item) * N stack items + 1 byte buffer
         len_scriptsig = len(psbt_in["final_scriptSig"]["hex"]) // 2 if "final_scriptSig" in psbt_in else 0
-- 
2.36.1


From 2b14847d07b7db6e04efaa6278f33c96708d371f Mon Sep 17 00:00:00 2001
From: Andrew Chow <achow101-github@achow101.com>
Date: Mon, 5 Apr 2021 16:17:34 -0400
Subject: [PATCH 47/48] Add a PSBT constructor for providing the version

Also changes CTransaction::CURRENT_VERSION to constexpr as otherwise
there will be a linker error.
---
 src/primitives/transaction.h | 2 +-
 src/psbt.cpp                 | 8 ++++++++
 src/psbt.h                   | 1 +
 3 files changed, 10 insertions(+), 1 deletion(-)

diff --git a/src/primitives/transaction.h b/src/primitives/transaction.h
index fb98fb6868..80dea6456f 100644
--- a/src/primitives/transaction.h
+++ b/src/primitives/transaction.h
@@ -280,7 +280,7 @@ class CTransaction
 {
 public:
     // Default transaction version.
-    static const int32_t CURRENT_VERSION=2;
+    static constexpr int32_t CURRENT_VERSION=2;
 
     // The local variables are made const to prevent unintended modification
     // without updating the cached hash value. However, CTransaction is not
diff --git a/src/psbt.cpp b/src/psbt.cpp
index cbd2d12135..61bf688332 100644
--- a/src/psbt.cpp
+++ b/src/psbt.cpp
@@ -19,6 +19,14 @@ PartiallySignedTransaction::PartiallySignedTransaction(const CMutableTransaction
     SetupFromTx(tx);
 }
 
+PartiallySignedTransaction::PartiallySignedTransaction(uint32_t version) :
+    m_version(version)
+{
+    if (GetVersion() >= 2) {
+        tx_version = CTransaction::CURRENT_VERSION;
+    }
+}
+
 bool PartiallySignedTransaction::IsNull() const
 {
     return !tx && inputs.empty() && outputs.empty() && unknown.empty();
diff --git a/src/psbt.h b/src/psbt.h
index 6ddd8d6235..08eee2cc9d 100644
--- a/src/psbt.h
+++ b/src/psbt.h
@@ -1138,6 +1138,7 @@ struct PartiallySignedTransaction
     CMutableTransaction GetUnsignedTx() const;
     uint256 GetUniqueID() const;
     PartiallySignedTransaction() {}
+    PartiallySignedTransaction(uint32_t version);
     explicit PartiallySignedTransaction(const CMutableTransaction& tx, uint32_t version = 0);
 
     template <typename Stream>
-- 
2.36.1


From 527dd83827220f2f23916cf18032eae40ef1d088 Mon Sep 17 00:00:00 2001
From: Andrew Chow <achow101-github@achow101.com>
Date: Mon, 5 Apr 2021 16:39:48 -0400
Subject: [PATCH 48/48] Use GetUnsignedTx when serializing in PSBTv0

If we are asked to make a PSBTv0, we may not necessarily have made an
unsigned transaction. So instead use GetUnsignedTx which will either
fetch one that already exists, or construct a new one from the stored
data. Internally we may be storing a PSBTv0 like a PSBTv2, but still
want to serialize those as v0.
---
 src/psbt.h | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/psbt.h b/src/psbt.h
index 08eee2cc9d..6707252ae5 100644
--- a/src/psbt.h
+++ b/src/psbt.h
@@ -1153,7 +1153,7 @@ struct PartiallySignedTransaction
 
             // Write serialized tx to a stream
             OverrideStream<Stream> os(&s, s.GetType(), s.GetVersion() | SERIALIZE_TRANSACTION_NO_WITNESS);
-            SerializeToVector(os, *tx);
+            SerializeToVector(os, GetUnsignedTx());
         }
 
         // Write xpubs
-- 
2.36.1

